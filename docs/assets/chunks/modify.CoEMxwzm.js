import{a4 as H,at as Y,au as K,av as X,ab as $,aw as z,b as J,V as Q,ax as b,ay as B,az as A,E as R,ag as m,aA as w,ai as L,P as k,ae as P,aB as S,aC as y,ah as j,a8 as _,aD as M,aE as Z,aF as ee,aG as te,a9 as I,aH as ie,al as ne,am as se,aI as re,aJ as oe,aK as ae,d as he}from"./index.p3HzktB-.js";const O=0,C=1,N=[0,0,0,0],F=[],G={MODIFYSTART:"modifystart",MODIFYEND:"modifyend"};class D extends se{constructor(e,t,i){super(e),this.features=t,this.mapBrowserEvent=i}}class de extends H{constructor(e){super(e),this.on,this.once,this.un,this.boundHandleFeatureChange_=this.handleFeatureChange_.bind(this),this.condition_=e.condition?e.condition:Y,this.defaultDeleteCondition_=function(i){return K(i)&&X(i)},this.deleteCondition_=e.deleteCondition?e.deleteCondition:this.defaultDeleteCondition_,this.insertVertexCondition_=e.insertVertexCondition?e.insertVertexCondition:$,this.vertexFeature_=null,this.vertexSegments_=null,this.lastPixel_=[0,0],this.ignoreNextSingleClick_=!1,this.featuresBeingModified_=null,this.rBush_=new z,this.pixelTolerance_=e.pixelTolerance!==void 0?e.pixelTolerance:10,this.snappedToVertex_=!1,this.changingFeature_=!1,this.dragSegments_=[],this.overlay_=new J({source:new Q({useSpatialIndex:!1,wrapX:!!e.wrapX}),style:e.style?e.style:le(),updateWhileAnimating:!0,updateWhileInteracting:!0}),this.SEGMENT_WRITERS_={Point:this.writePointGeometry_.bind(this),LineString:this.writeLineStringGeometry_.bind(this),LinearRing:this.writeLineStringGeometry_.bind(this),Polygon:this.writePolygonGeometry_.bind(this),MultiPoint:this.writeMultiPointGeometry_.bind(this),MultiLineString:this.writeMultiLineStringGeometry_.bind(this),MultiPolygon:this.writeMultiPolygonGeometry_.bind(this),Circle:this.writeCircleGeometry_.bind(this),GeometryCollection:this.writeGeometryCollectionGeometry_.bind(this)},this.source_=null,this.hitDetection_=null;let t;if(e.features?t=e.features:e.source&&(this.source_=e.source,t=new b(this.source_.getFeatures()),this.source_.addEventListener(B.ADDFEATURE,this.handleSourceAdd_.bind(this)),this.source_.addEventListener(B.REMOVEFEATURE,this.handleSourceRemove_.bind(this))),!t)throw new Error("The modify interaction requires features, a source or a layer");e.hitDetection&&(this.hitDetection_=e.hitDetection),this.features_=t,this.features_.forEach(this.addFeature_.bind(this)),this.features_.addEventListener(A.ADD,this.handleFeatureAdd_.bind(this)),this.features_.addEventListener(A.REMOVE,this.handleFeatureRemove_.bind(this)),this.lastPointerEvent_=null,this.delta_=[0,0],this.snapToPointer_=e.snapToPointer===void 0?!this.hitDetection_:e.snapToPointer}addFeature_(e){const t=e.getGeometry();if(t){const n=this.SEGMENT_WRITERS_[t.getType()];n&&n(e,t)}const i=this.getMap();i&&i.isRendered()&&this.getActive()&&this.handlePointerAtPixel_(i.getCoordinateFromPixel(this.lastPixel_)),e.addEventListener(R.CHANGE,this.boundHandleFeatureChange_)}willModifyFeatures_(e,t){if(!this.featuresBeingModified_){this.featuresBeingModified_=new b;const i=this.featuresBeingModified_.getArray();for(let n=0,s=t.length;n<s;++n){const a=t[n].feature;a&&!i.includes(a)&&this.featuresBeingModified_.push(a)}this.featuresBeingModified_.getLength()===0?this.featuresBeingModified_=null:this.dispatchEvent(new D(G.MODIFYSTART,this.featuresBeingModified_,e))}}removeFeature_(e){this.removeFeatureSegmentData_(e),this.vertexFeature_&&this.features_.getLength()===0&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.removeEventListener(R.CHANGE,this.boundHandleFeatureChange_)}removeFeatureSegmentData_(e){const t=this.rBush_,i=[];t.forEach(function(n){e===n.feature&&i.push(n)});for(let n=i.length-1;n>=0;--n){const s=i[n];for(let a=this.dragSegments_.length-1;a>=0;--a)this.dragSegments_[a][0]===s&&this.dragSegments_.splice(a,1);t.remove(s)}}setActive(e){this.vertexFeature_&&!e&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),super.setActive(e)}setMap(e){this.overlay_.setMap(e),super.setMap(e)}getOverlay(){return this.overlay_}handleSourceAdd_(e){e.feature&&this.features_.push(e.feature)}handleSourceRemove_(e){e.feature&&this.features_.remove(e.feature)}handleFeatureAdd_(e){this.addFeature_(e.element)}handleFeatureChange_(e){if(!this.changingFeature_){const t=e.target;this.removeFeature_(t),this.addFeature_(t)}}handleFeatureRemove_(e){this.removeFeature_(e.element)}writePointGeometry_(e,t){const i=t.getCoordinates(),n={feature:e,geometry:t,segment:[i,i]};this.rBush_.insert(t.getExtent(),n)}writeMultiPointGeometry_(e,t){const i=t.getCoordinates();for(let n=0,s=i.length;n<s;++n){const a=i[n],r={feature:e,geometry:t,depth:[n],index:n,segment:[a,a]};this.rBush_.insert(t.getExtent(),r)}}writeLineStringGeometry_(e,t){const i=t.getCoordinates();for(let n=0,s=i.length-1;n<s;++n){const a=i.slice(n,n+2),r={feature:e,geometry:t,index:n,segment:a};this.rBush_.insert(m(a),r)}}writeMultiLineStringGeometry_(e,t){const i=t.getCoordinates();for(let n=0,s=i.length;n<s;++n){const a=i[n];for(let r=0,o=a.length-1;r<o;++r){const d=a.slice(r,r+2),h={feature:e,geometry:t,depth:[n],index:r,segment:d};this.rBush_.insert(m(d),h)}}}writePolygonGeometry_(e,t){const i=t.getCoordinates();for(let n=0,s=i.length;n<s;++n){const a=i[n];for(let r=0,o=a.length-1;r<o;++r){const d=a.slice(r,r+2),h={feature:e,geometry:t,depth:[n],index:r,segment:d};this.rBush_.insert(m(d),h)}}}writeMultiPolygonGeometry_(e,t){const i=t.getCoordinates();for(let n=0,s=i.length;n<s;++n){const a=i[n];for(let r=0,o=a.length;r<o;++r){const d=a[r];for(let h=0,u=d.length-1;h<u;++h){const g=d.slice(h,h+2),l={feature:e,geometry:t,depth:[r,n],index:h,segment:g};this.rBush_.insert(m(g),l)}}}}writeCircleGeometry_(e,t){const i=t.getCenter(),n={feature:e,geometry:t,index:O,segment:[i,i]},s={feature:e,geometry:t,index:C,segment:[i,i]},a=[n,s];n.featureSegments=a,s.featureSegments=a,this.rBush_.insert(w(i),n);let r=t;this.rBush_.insert(r.getExtent(),s)}writeGeometryCollectionGeometry_(e,t){const i=t.getGeometriesArray();for(let n=0;n<i.length;++n){const s=i[n],a=this.SEGMENT_WRITERS_[s.getType()];a(e,s)}}createOrUpdateVertexFeature_(e,t,i,n){let s=this.vertexFeature_;return s?s.getGeometry().setCoordinates(e):(s=new L(new k(e)),this.vertexFeature_=s,this.overlay_.getSource().addFeature(s)),s.set("features",t),s.set("geometries",i),s.set("existing",n),s}handleEvent(e){if(!e.originalEvent)return!0;this.lastPointerEvent_=e;let t;return!e.map.getView().getInteracting()&&e.type==P.POINTERMOVE&&!this.handlingDownUpSequence&&this.handlePointerMove_(e),this.vertexFeature_&&this.deleteCondition_(e)&&(e.type!=P.SINGLECLICK||!this.ignoreNextSingleClick_?t=this.removePoint():t=!0),e.type==P.SINGLECLICK&&(this.ignoreNextSingleClick_=!1),super.handleEvent(e)&&!t}findInsertVerticesAndUpdateDragSegments_(e){this.handlePointerAtPixel_(e),this.dragSegments_.length=0,this.featuresBeingModified_=null;const t=this.vertexFeature_;if(!t)return;this.getMap().getView().getProjection();const i=[],n=t.getGeometry().getCoordinates(),s=m([n]),a=this.rBush_.getInExtent(s),r={};a.sort(ge);for(let o=0,d=a.length;o<d;++o){const h=a[o],u=h.segment;let g=S(h.geometry);const l=h.depth;if(l&&(g+="-"+l.join("-")),r[g]||(r[g]=new Array(2)),h.geometry.getType()==="Circle"&&h.index===C){const c=q(e,h);y(c,n)&&!r[g][0]&&(this.dragSegments_.push([h,0]),r[g][0]=h);continue}if(y(u[0],n)&&!r[g][0]){this.dragSegments_.push([h,0]),r[g][0]=h;continue}if(y(u[1],n)&&!r[g][1]){if(r[g][0]&&r[g][0].index===0){let c=h.geometry.getCoordinates();switch(h.geometry.getType()){case"LineString":case"MultiLineString":continue;case"MultiPolygon":c=c[l[1]];case"Polygon":if(h.index!==c[l[0]].length-2)continue;break}}this.dragSegments_.push([h,1]),r[g][1]=h;continue}S(u)in this.vertexSegments_&&!r[g][0]&&!r[g][1]&&i.push(h)}return i}handleDragEvent(e){this.ignoreNextSingleClick_=!1,this.willModifyFeatures_(e,this.dragSegments_.map(([s])=>s));const t=[e.coordinate[0]+this.delta_[0],e.coordinate[1]+this.delta_[1]],i=[],n=[];for(let s=0,a=this.dragSegments_.length;s<a;++s){const r=this.dragSegments_[s],o=r[0],d=o.feature;i.includes(d)||i.push(d);const h=o.geometry;n.includes(h)||n.push(h);const u=o.depth;let g;const l=o.segment,c=r[1];for(;t.length<h.getStride();)t.push(l[c][t.length]);switch(h.getType()){case"Point":g=t,l[0]=t,l[1]=t;break;case"MultiPoint":g=h.getCoordinates(),g[o.index]=t,l[0]=t,l[1]=t;break;case"LineString":g=h.getCoordinates(),g[o.index+c]=t,l[c]=t;break;case"MultiLineString":g=h.getCoordinates(),g[u[0]][o.index+c]=t,l[c]=t;break;case"Polygon":g=h.getCoordinates(),g[u[0]][o.index+c]=t,l[c]=t;break;case"MultiPolygon":g=h.getCoordinates(),g[u[1]][u[0]][o.index+c]=t,l[c]=t;break;case"Circle":const x=h;if(l[0]=t,l[1]=t,o.index===O)this.changingFeature_=!0,x.setCenter(t),this.changingFeature_=!1;else{this.changingFeature_=!0,e.map.getView().getProjection();let p=j(_(x.getCenter()),_(t));x.setRadius(p),this.changingFeature_=!1}break}g&&this.setGeometryCoordinates_(h,g)}this.createOrUpdateVertexFeature_(t,i,n,!0)}handleDownEvent(e){if(!this.condition_(e))return!1;const t=e.coordinate,i=this.findInsertVerticesAndUpdateDragSegments_(t);if(i!=null&&i.length&&this.insertVertexCondition_(e)&&(this.willModifyFeatures_(e,i),this.vertexFeature_)){const n=this.vertexFeature_.getGeometry().getCoordinates();for(let s=i.length-1;s>=0;--s)this.insertVertex_(i[s],n);this.ignoreNextSingleClick_=!0}return!!this.vertexFeature_}handleUpEvent(e){for(let t=this.dragSegments_.length-1;t>=0;--t){const i=this.dragSegments_[t][0],n=i.geometry;if(n.getType()==="Circle"){const s=n,a=s.getCenter(),r=i.featureSegments[0],o=i.featureSegments[1];r.segment[0]=a,r.segment[1]=a,o.segment[0]=a,o.segment[1]=a,this.rBush_.update(w(a),r);let d=s;this.rBush_.update(d.getExtent(),o)}else this.rBush_.update(m(i.segment),i)}return this.featuresBeingModified_&&(this.dispatchEvent(new D(G.MODIFYEND,this.featuresBeingModified_,e)),this.featuresBeingModified_=null),!1}handlePointerMove_(e){this.lastPixel_=e.pixel,this.handlePointerAtPixel_(e.coordinate)}handlePointerAtPixel_(e){const t=this.getMap(),i=t.getPixelFromCoordinate(e);t.getView().getProjection();const n=function(r,o){return U(e,r)-U(e,o)};let s,a;if(this.hitDetection_){const r=typeof this.hitDetection_=="object"?o=>o===this.hitDetection_:void 0;t.forEachFeatureAtPixel(i,(o,d,h)=>{h&&h.getType()==="Point"&&(h=new k(M(h.getCoordinates())));const u=h||o.getGeometry();if(u&&u.getType()==="Point"&&o instanceof L&&this.features_.getArray().includes(o)){a=u;const g=o.getGeometry().getFlatCoordinates().slice(0,2);s=[{feature:o,geometry:a,segment:[g,g]}]}return!0},{layerFilter:r})}if(!s){const r=Z(w(e,N)),o=t.getView().getResolution()*this.pixelTolerance_,d=ee(te(r,o,N));s=this.rBush_.getInExtent(d)}if(s&&s.length>0){const r=s.sort(n)[0],o=r.segment;let d=q(e,r);const h=t.getPixelFromCoordinate(d);let u=j(i,h);if(a||u<=this.pixelTolerance_){const g={};if(g[S(o)]=!0,this.snapToPointer_||(this.delta_[0]=d[0]-e[0],this.delta_[1]=d[1]-e[1]),r.geometry.getType()==="Circle"&&r.index===C)this.snappedToVertex_=!0,this.createOrUpdateVertexFeature_(d,[r.feature],[r.geometry],this.snappedToVertex_);else{const l=t.getPixelFromCoordinate(o[0]),c=t.getPixelFromCoordinate(o[1]),x=I(h,l),p=I(h,c);if(u=Math.sqrt(Math.min(x,p)),this.snappedToVertex_=u<=this.pixelTolerance_,!this.snappedToVertex_&&!this.insertVertexCondition_(this.lastPointerEvent_)){this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null);return}this.snappedToVertex_&&(d=x>p?o[1]:o[0]),this.createOrUpdateVertexFeature_(d,[r.feature],[r.geometry],this.snappedToVertex_);const T={};T[S(r.geometry)]=!0;for(let E=1,W=s.length;E<W;++E){const v=s[E].segment;if(y(o[0],v[0])&&y(o[1],v[1])||y(o[0],v[1])&&y(o[1],v[0])){const V=S(s[E].geometry);V in T||(T[V]=!0,g[S(v)]=!0)}else break}}this.vertexSegments_=g;return}}this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null)}insertVertex_(e,t){const i=e.segment,n=e.feature,s=e.geometry,a=e.depth,r=e.index;let o;for(;t.length<s.getStride();)t.push(0);switch(s.getType()){case"MultiLineString":o=s.getCoordinates(),o[a[0]].splice(r+1,0,t);break;case"Polygon":o=s.getCoordinates(),o[a[0]].splice(r+1,0,t);break;case"MultiPolygon":o=s.getCoordinates(),o[a[1]][a[0]].splice(r+1,0,t);break;case"LineString":o=s.getCoordinates(),o.splice(r+1,0,t);break;default:return!1}this.setGeometryCoordinates_(s,o);const d=this.rBush_;d.remove(e),this.updateSegmentIndices_(s,r,a,1);const h={segment:[i[0],t],feature:n,geometry:s,depth:a,index:r};d.insert(m(h.segment),h),this.dragSegments_.push([h,1]);const u={segment:[t,i[1]],feature:n,geometry:s,depth:a,index:r+1};return d.insert(m(u.segment),u),this.dragSegments_.push([u,0]),!0}updatePointer_(e){var t;return e&&this.findInsertVerticesAndUpdateDragSegments_(e),(t=this.vertexFeature_)==null?void 0:t.getGeometry().getCoordinates()}getPoint(){var t;const e=(t=this.vertexFeature_)==null?void 0:t.getGeometry().getCoordinates();return e?M(e,this.getMap().getView().getProjection()):null}canRemovePoint(){if(!this.vertexFeature_||this.vertexFeature_.get("geometries").every(i=>i.getType()==="Circle"||i.getType().endsWith("Point")))return!1;const e=this.vertexFeature_.getGeometry().getCoordinates();return this.rBush_.getInExtent(m([e])).some(({segment:i})=>y(i[0],e)||y(i[1],e))}removePoint(e){if(e&&(e=_(e,this.getMap().getView().getProjection()),this.updatePointer_(e)),!this.lastPointerEvent_||this.lastPointerEvent_&&this.lastPointerEvent_.type!=P.POINTERDRAG){const t=this.lastPointerEvent_;this.willModifyFeatures_(t,this.dragSegments_.map(([n])=>n));const i=this.removeVertex_();return this.featuresBeingModified_&&this.dispatchEvent(new D(G.MODIFYEND,this.featuresBeingModified_,t)),this.featuresBeingModified_=null,i}return!1}removeVertex_(){const e=this.dragSegments_,t={};let i=!1,n,s,a,r,o,d,h,u,g,l,c;for(o=e.length-1;o>=0;--o)a=e[o],l=a[0],c=S(l.feature),l.depth&&(c+="-"+l.depth.join("-")),c in t||(t[c]={}),a[1]===0?(t[c].right=l,t[c].index=l.index):a[1]==1&&(t[c].left=l,t[c].index=l.index+1);for(c in t){switch(g=t[c].right,h=t[c].left,d=t[c].index,u=d-1,h!==void 0?l=h:l=g,u<0&&(u=0),r=l.geometry,s=r.getCoordinates(),n=s,i=!1,r.getType()){case"MultiLineString":s[l.depth[0]].length>2&&(s[l.depth[0]].splice(d,1),i=!0);break;case"LineString":s.length>2&&(s.splice(d,1),i=!0);break;case"MultiPolygon":n=n[l.depth[1]];case"Polygon":n=n[l.depth[0]],n.length>4&&(d==n.length-1&&(d=0),n.splice(d,1),i=!0,d===0&&(n.pop(),n.push(n[0]),u=n.length-1));break}if(i){this.setGeometryCoordinates_(r,s);const x=[];if(h!==void 0&&(this.rBush_.remove(h),x.push(h.segment[0])),g!==void 0&&(this.rBush_.remove(g),x.push(g.segment[1])),h!==void 0&&g!==void 0){const p={depth:l.depth,feature:l.feature,geometry:l.geometry,index:u,segment:x};this.rBush_.insert(m(p.segment),p)}this.updateSegmentIndices_(r,d,l.depth,-1),this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.length=0}}return i}canInsertPoint(){if(!this.vertexFeature_||this.vertexFeature_.get("geometries").every(i=>i.getType()==="Circle"||i.getType().endsWith("Point")))return!1;const e=this.vertexFeature_.getGeometry().getCoordinates();return this.rBush_.getInExtent(m([e])).some(({segment:i})=>!(y(i[0],e)||y(i[1],e)))}insertPoint(e){var n;const t=e?_(e,this.getMap().getView().getProjection()):(n=this.vertexFeature_)==null?void 0:n.getGeometry().getCoordinates();return t?this.findInsertVerticesAndUpdateDragSegments_(t).reduce((s,a)=>s||this.insertVertex_(a,t),!1):!1}setGeometryCoordinates_(e,t){this.changingFeature_=!0,e.setCoordinates(t),this.changingFeature_=!1}updateSegmentIndices_(e,t,i,n){this.rBush_.forEachInExtent(e.getExtent(),function(s){s.geometry===e&&(i===void 0||s.depth===void 0||ie(s.depth,i))&&s.index>t&&(s.index+=n)})}}function ge(f,e){return f.index-e.index}function U(f,e,t){const i=e.geometry;if(i.getType()==="Circle"){let s=i;if(e.index===C){const a=I(s.getCenter(),_(f)),r=Math.sqrt(a)-s.getRadius();return r*r}}const n=_(f);return F[0]=_(e.segment[0]),F[1]=_(e.segment[1]),oe(n,F)}function q(f,e,t){const i=e.geometry;if(i.getType()==="Circle"&&e.index===C)return M(i.getClosestPoint(_(f)));const n=_(f);return F[0]=_(e.segment[0]),F[1]=_(e.segment[1]),M(re(n,F))}function le(){const f=ne();return function(e,t){return f.Point}}function ce(f,e=!0){let t=f.getInteractiveByType("modify");if(t)return t;const i=f.getOlMap(),n=f.getEmitter(),s=f.getContainer(),a=new b([]),r=new de({features:a});let o=[];return r.on("modifyend",d=>{const h=d.features.getArray()??[];e&&h.forEach(u=>{ae(u,s)}),n.emit("modify",o)}),t={id:he(),type:"modify",enabled:!1,add(d){o.findIndex(u=>u.id===d.id)===-1&&(o.push(d),a.push(d.getOlFeature()))},remove(d){const h=o.findIndex(u=>u.id===d.id);h!==-1&&(o.splice(h,1),a.remove(d.getOlFeature()))},clean(){o=[],a.clear()},enable(){t.enabled||(i.addInteraction(r),t.enabled=!0)},close(){t.enabled&&(i.removeInteraction(r),t.enabled=!1)},destroy(){t.clean(),t.close(),r.dispose()}},t}export{ce as c};
