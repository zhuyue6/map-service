import{G as Q,u as tt,l as et,E as W,n as I,p as st,q as it,s as nt,t as Y,v as P,w as ot,x as rt,y as at,z as ht,L as w,A as lt,D as dt,H as ct,I as ft,J as gt,K as V,N as ut,P as T,O as _t,Q as Ct,R as mt,T as pt,U as yt,W as Pt,X as U,Y as wt,Z as kt,_ as Tt,$ as xt,a0 as Ft,a1 as x,a2 as Dt,a3 as Lt,a4 as Et,a5 as Mt,a6 as St,a7 as Rt,a8 as X,a9 as Gt,b as It,V as vt,aa as At,ab as q,ac as Ot,ad as Nt,ae as C,af as jt,ag as B,ah as K,ai as k,aj as b,ak as Xt,al as Yt,am as Vt,an as Ut,ao as H,ap as qt,aq as bt,ar as Ht,as as Wt}from"./index.p3HzktB-.js";class G extends Q{constructor(t){super(),this.geometries_=t,this.changeEventsKeys_=[],this.listenGeometriesChange_()}unlistenGeometriesChange_(){this.changeEventsKeys_.forEach(tt),this.changeEventsKeys_.length=0}listenGeometriesChange_(){const t=this.geometries_;for(let e=0,s=t.length;e<s;++e)this.changeEventsKeys_.push(et(t[e],W.CHANGE,this.changed,this))}clone(){const t=new G(O(this.geometries_));return t.applyProperties(this),t}closestPointXY(t,e,s,i){if(i<I(this.getExtent(),t,e))return i;const n=this.geometries_;for(let o=0,r=n.length;o<r;++o)i=n[o].closestPointXY(t,e,s,i);return i}containsXY(t,e){const s=this.geometries_;for(let i=0,n=s.length;i<n;++i)if(s[i].containsXY(t,e))return!0;return!1}computeExtent(t){st(t);const e=this.geometries_;for(let s=0,i=e.length;s<i;++s)it(t,e[s].getExtent());return t}getGeometries(){return O(this.geometries_)}getGeometriesArray(){return this.geometries_}getGeometriesArrayRecursive(){let t=[];const e=this.geometries_;for(let s=0,i=e.length;s<i;++s)e[s].getType()===this.getType()?t=t.concat(e[s].getGeometriesArrayRecursive()):t.push(e[s]);return t}getSimplifiedGeometry(t){if(this.simplifiedGeometryRevision!==this.getRevision()&&(this.simplifiedGeometryMaxMinSquaredTolerance=0,this.simplifiedGeometryRevision=this.getRevision()),t<0||this.simplifiedGeometryMaxMinSquaredTolerance!==0&&t<this.simplifiedGeometryMaxMinSquaredTolerance)return this;const e=[],s=this.geometries_;let i=!1;for(let n=0,o=s.length;n<o;++n){const r=s[n],a=r.getSimplifiedGeometry(t);e.push(a),a!==r&&(i=!0)}return i?new G(e):(this.simplifiedGeometryMaxMinSquaredTolerance=t,this)}getType(){return"GeometryCollection"}intersectsExtent(t){const e=this.geometries_;for(let s=0,i=e.length;s<i;++s)if(e[s].intersectsExtent(t))return!0;return!1}isEmpty(){return this.geometries_.length===0}rotate(t,e){const s=this.geometries_;for(let i=0,n=s.length;i<n;++i)s[i].rotate(t,e);this.changed()}scale(t,e,s){s||(s=nt(this.getExtent()));const i=this.geometries_;for(let n=0,o=i.length;n<o;++n)i[n].scale(t,e,s);this.changed()}setGeometries(t){this.setGeometriesArray(O(t))}setGeometriesArray(t){this.unlistenGeometriesChange_(),this.geometries_=t,this.listenGeometriesChange_(),this.changed()}applyTransform(t){const e=this.geometries_;for(let s=0,i=e.length;s<i;++s)e[s].applyTransform(t);this.changed()}translate(t,e){const s=this.geometries_;for(let i=0,n=s.length;i<n;++i)s[i].translate(t,e);this.changed()}disposeInternal(){this.unlistenGeometriesChange_(),super.disposeInternal()}}function O(h){return h.map(t=>t.clone())}class F extends Y{constructor(t,e,s){if(super(),this.ends_=[],this.maxDelta_=-1,this.maxDeltaRevision_=-1,Array.isArray(t[0]))this.setCoordinates(t,e);else if(e!==void 0&&s)this.setFlatCoordinates(e,t),this.ends_=s;else{const i=t,n=[],o=[];for(let a=0,l=i.length;a<l;++a){const c=i[a];P(n,c.getFlatCoordinates()),o.push(n.length)}const r=i.length===0?this.getLayout():i[0].getLayout();this.setFlatCoordinates(r,n),this.ends_=o}}appendLineString(t){P(this.flatCoordinates,t.getFlatCoordinates().slice()),this.ends_.push(this.flatCoordinates.length),this.changed()}clone(){const t=new F(this.flatCoordinates.slice(),this.layout,this.ends_.slice());return t.applyProperties(this),t}closestPointXY(t,e,s,i){return i<I(this.getExtent(),t,e)?i:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(ot(this.flatCoordinates,0,this.ends_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),rt(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,!1,t,e,s,i))}getCoordinateAtM(t,e,s){return this.layout!="XYM"&&this.layout!="XYZM"||this.flatCoordinates.length===0?null:(e=e!==void 0?e:!1,s=s!==void 0?s:!1,at(this.flatCoordinates,0,this.ends_,this.stride,t,e,s))}getCoordinates(){return ht(this.flatCoordinates,0,this.ends_,this.stride)}getEnds(){return this.ends_}getLineString(t){return t<0||this.ends_.length<=t?null:new w(this.flatCoordinates.slice(t===0?0:this.ends_[t-1],this.ends_[t]),this.layout)}getLineStrings(){const t=this.flatCoordinates,e=this.ends_,s=this.layout,i=[];let n=0;for(let o=0,r=e.length;o<r;++o){const a=e[o],l=new w(t.slice(n,a),s);i.push(l),n=a}return i}getLength(){const t=this.ends_;let e=0,s=0;for(let i=0,n=t.length;i<n;++i)s+=lt(this.flatCoordinates,e,t[i],this.stride),e=t[i];return s}getFlatMidpoints(){const t=[],e=this.flatCoordinates;let s=0;const i=this.ends_,n=this.stride;for(let o=0,r=i.length;o<r;++o){const a=i[o],l=dt(e,s,a,n,.5);P(t,l),s=a}return t}getSimplifiedGeometryInternal(t){const e=[],s=[];return e.length=ct(this.flatCoordinates,0,this.ends_,this.stride,t,e,0,s),new F(e,"XY",s)}getType(){return"MultiLineString"}intersectsExtent(t){return ft(this.flatCoordinates,0,this.ends_,this.stride,t)}setCoordinates(t,e){this.setLayout(e,t,2),this.flatCoordinates||(this.flatCoordinates=[]);const s=gt(this.flatCoordinates,0,t,this.stride,this.ends_);this.flatCoordinates.length=s.length===0?0:s[s.length-1],this.changed()}}class v extends Y{constructor(t,e){super(),e&&!Array.isArray(t[0])?this.setFlatCoordinates(e,t):this.setCoordinates(t,e)}appendPoint(t){P(this.flatCoordinates,t.getFlatCoordinates()),this.changed()}clone(){const t=new v(this.flatCoordinates.slice(),this.layout);return t.applyProperties(this),t}closestPointXY(t,e,s,i){if(i<I(this.getExtent(),t,e))return i;const n=this.flatCoordinates,o=this.stride;for(let r=0,a=n.length;r<a;r+=o){const l=V(t,e,n[r],n[r+1]);if(l<i){i=l;for(let c=0;c<o;++c)s[c]=n[r+c];s.length=o}}return i}getCoordinates(){return ut(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)}getPoint(t){const e=this.flatCoordinates.length/this.stride;return t<0||e<=t?null:new T(this.flatCoordinates.slice(t*this.stride,(t+1)*this.stride),this.layout)}getPoints(){const t=this.flatCoordinates,e=this.layout,s=this.stride,i=[];for(let n=0,o=t.length;n<o;n+=s){const r=new T(t.slice(n,n+s),e);i.push(r)}return i}getType(){return"MultiPoint"}intersectsExtent(t){const e=this.flatCoordinates,s=this.stride;for(let i=0,n=e.length;i<n;i+=s){const o=e[i],r=e[i+1];if(_t(t,o,r))return!0}return!1}setCoordinates(t,e){this.setLayout(e,t,1),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=Ct(this.flatCoordinates,0,t,this.stride),this.changed()}}class D extends Y{constructor(t,e,s){if(super(),this.endss_=[],this.flatInteriorPointsRevision_=-1,this.flatInteriorPoints_=null,this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.orientedRevision_=-1,this.orientedFlatCoordinates_=null,!s&&!Array.isArray(t[0])){const i=t,n=[],o=[];for(let r=0,a=i.length;r<a;++r){const l=i[r],c=n.length,d=l.getEnds();for(let f=0,g=d.length;f<g;++f)d[f]+=c;P(n,l.getFlatCoordinates()),o.push(d)}e=i.length===0?this.getLayout():i[0].getLayout(),t=n,s=o}e!==void 0&&s?(this.setFlatCoordinates(e,t),this.endss_=s):this.setCoordinates(t,e)}appendPolygon(t){let e;if(!this.flatCoordinates)this.flatCoordinates=t.getFlatCoordinates().slice(),e=t.getEnds().slice(),this.endss_.push();else{const s=this.flatCoordinates.length;P(this.flatCoordinates,t.getFlatCoordinates()),e=t.getEnds().slice();for(let i=0,n=e.length;i<n;++i)e[i]+=s}this.endss_.push(e),this.changed()}clone(){const t=this.endss_.length,e=new Array(t);for(let i=0;i<t;++i)e[i]=this.endss_[i].slice();const s=new D(this.flatCoordinates.slice(),this.layout,e);return s.applyProperties(this),s}closestPointXY(t,e,s,i){return i<I(this.getExtent(),t,e)?i:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(mt(this.flatCoordinates,0,this.endss_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),pt(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,this.maxDelta_,!0,t,e,s,i))}containsXY(t,e){return yt(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t,e)}getArea(){return Pt(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride)}getCoordinates(t){let e;return t!==void 0?(e=this.getOrientedFlatCoordinates().slice(),U(e,0,this.endss_,this.stride,t)):e=this.flatCoordinates,wt(e,0,this.endss_,this.stride)}getEndss(){return this.endss_}getFlatInteriorPoints(){if(this.flatInteriorPointsRevision_!=this.getRevision()){const t=kt(this.flatCoordinates,0,this.endss_,this.stride);this.flatInteriorPoints_=Tt(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t),this.flatInteriorPointsRevision_=this.getRevision()}return this.flatInteriorPoints_}getInteriorPoints(){return new v(this.getFlatInteriorPoints().slice(),"XYM")}getOrientedFlatCoordinates(){if(this.orientedRevision_!=this.getRevision()){const t=this.flatCoordinates;xt(t,0,this.endss_,this.stride)?this.orientedFlatCoordinates_=t:(this.orientedFlatCoordinates_=t.slice(),this.orientedFlatCoordinates_.length=U(this.orientedFlatCoordinates_,0,this.endss_,this.stride)),this.orientedRevision_=this.getRevision()}return this.orientedFlatCoordinates_}getSimplifiedGeometryInternal(t){const e=[],s=[];return e.length=Ft(this.flatCoordinates,0,this.endss_,this.stride,Math.sqrt(t),e,0,s),new D(e,"XY",s)}getPolygon(t){if(t<0||this.endss_.length<=t)return null;let e;if(t===0)e=0;else{const n=this.endss_[t-1];e=n[n.length-1]}const s=this.endss_[t].slice(),i=s[s.length-1];if(e!==0)for(let n=0,o=s.length;n<o;++n)s[n]-=e;return new x(this.flatCoordinates.slice(e,i),this.layout,s)}getPolygons(){const t=this.layout,e=this.flatCoordinates,s=this.endss_,i=[];let n=0;for(let o=0,r=s.length;o<r;++o){const a=s[o].slice(),l=a[a.length-1];if(n!==0)for(let d=0,f=a.length;d<f;++d)a[d]-=n;const c=new x(e.slice(n,l),t,a);i.push(c),n=l}return i}getType(){return"MultiPolygon"}intersectsExtent(t){return Dt(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,t)}setCoordinates(t,e){this.setLayout(e,t,3),this.flatCoordinates||(this.flatCoordinates=[]);const s=Lt(this.flatCoordinates,0,t,this.stride,this.endss_);if(s.length===0)this.flatCoordinates.length=0;else{const i=s[s.length-1];this.flatCoordinates.length=i.length===0?0:i[i.length-1]}this.changed()}}const L={DRAWSTART:"drawstart",DRAWEND:"drawend",DRAWABORT:"drawabort"};class E extends Vt{constructor(t,e){super(t),this.feature=e}}function Bt(h,t){const e=[];for(let s=0;s<t.length;++s){const n=t[s].getGeometry();$(h,n,e)}return e}function M(h,t){return V(h[0],h[1],t[0],t[1])}function p(h,t){const e=h.length;return t<0?h[t+e]:t>=e?h[t-e]:h[t]}function S(h,t,e){let s,i;t<e?(s=t,i=e):(s=e,i=t);const n=Math.ceil(s),o=Math.floor(i);if(n>o){const a=y(h,s),l=y(h,i);return M(a,l)}let r=0;if(s<n){const a=y(h,s),l=p(h,n);r+=M(a,l)}if(o<i){const a=p(h,o),l=y(h,i);r+=M(a,l)}for(let a=n;a<o-1;++a){const l=p(h,a),c=p(h,a+1);r+=M(l,c)}return r}function $(h,t,e){if(t instanceof w){R(h,t.getCoordinates(),!1,e);return}if(t instanceof F){const s=t.getCoordinates();for(let i=0,n=s.length;i<n;++i)R(h,s[i],!1,e);return}if(t instanceof x){const s=t.getCoordinates();for(let i=0,n=s.length;i<n;++i)R(h,s[i],!0,e);return}if(t instanceof D){const s=t.getCoordinates();for(let i=0,n=s.length;i<n;++i){const o=s[i];for(let r=0,a=o.length;r<a;++r)R(h,o[r],!0,e)}return}if(t instanceof G){const s=t.getGeometries();for(let i=0;i<s.length;++i)$(h,s[i],e);return}}const N={index:-1,endIndex:NaN};function Kt(h,t,e,s){const i=h[0],n=h[1];let o=1/0,r=-1,a=NaN;for(let d=0;d<t.targets.length;++d){const f=t.targets[d],g=f.coordinates;let u=1/0,_;for(let m=0;m<g.length-1;++m){const Z=g[m],J=g[m+1],A=z(i,n,Z,J);A.squaredDistance<u&&(u=A.squaredDistance,_=m+A.along)}u<o&&(o=u,f.ring&&t.targetIndex===d&&(f.endIndex>f.startIndex?_<f.startIndex&&(_+=g.length):f.endIndex<f.startIndex&&_>f.startIndex&&(_-=g.length)),a=_,r=d)}const l=t.targets[r];let c=l.ring;if(t.targetIndex===r&&c){const d=y(l.coordinates,a),f=e.getPixelFromCoordinate(d);K(f,t.startPx)>s&&(c=!1)}if(c){const d=l.coordinates,f=d.length,g=l.startIndex,u=a;if(g<u){const _=S(d,g,u);S(d,g,u-f)<_&&(a-=f)}else{const _=S(d,g,u);S(d,g,u+f)<_&&(a+=f)}}return N.index=r,N.endIndex=a,N}function R(h,t,e,s){const i=h[0],n=h[1];for(let o=0,r=t.length-1;o<r;++o){const a=t[o],l=t[o+1],c=z(i,n,a,l);if(c.squaredDistance===0){const d=o+c.along;s.push({coordinates:t,ring:e,startIndex:d,endIndex:d});return}}}const j={along:0,squaredDistance:0};function z(h,t,e,s){const i=e[0],n=e[1],o=s[0],r=s[1],a=o-i,l=r-n;let c=0,d=i,f=n;return(a!==0||l!==0)&&(c=Wt(((h-i)*a+(t-n)*l)/(a*a+l*l),0,1),d+=a*c,f+=l*c),j.along=c,j.squaredDistance=Ut(V(h,t,d,f),10),j}function y(h,t){const e=h.length;let s=Math.floor(t);const i=t-s;s>=e?s-=e:s<0&&(s+=e);let n=s+1;n>=e&&(n-=e);const o=h[s],r=o[0],a=o[1],l=h[n],c=l[0]-r,d=l[1]-a;return[r+c*i,a+d*i]}class Jt extends Et{constructor(t){const e=t;e.stopDown||(e.stopDown=Mt),super(e),this.on,this.once,this.un,this.shouldHandle_=!1,this.downPx_=null,this.downTimeout_,this.lastDragTime_,this.pointerType_,this.freehand_=!1,this.source_=t.source?t.source:null,this.features_=t.features?t.features:null,this.snapTolerance_=t.snapTolerance?t.snapTolerance:12,this.type_=t.type,this.mode_=zt(this.type_),this.stopClick_=!!t.stopClick,this.minPoints_=t.minPoints?t.minPoints:this.mode_==="Polygon"?3:2,this.maxPoints_=this.mode_==="Circle"?2:t.maxPoints?t.maxPoints:1/0,this.finishCondition_=t.finishCondition?t.finishCondition:St,this.geometryLayout_=t.geometryLayout?t.geometryLayout:"XY";let s=t.geometryFunction;if(!s){const i=this.mode_;if(i==="Circle")s=(n,o,r)=>{const a=o||new Rt([NaN,NaN]),l=X(n[0]),c=Gt(l,X(n[n.length-1]));return a.setCenterAndRadius(l,Math.sqrt(c),this.geometryLayout_),a};else{let n;i==="Point"?n=T:i==="LineString"?n=w:i==="Polygon"&&(n=x),s=(o,r,a)=>(r?i==="Polygon"?o[0].length?r.setCoordinates([o[0].concat([o[0][0]])],this.geometryLayout_):r.setCoordinates([],this.geometryLayout_):r.setCoordinates(o,this.geometryLayout_):r=new n(o,this.geometryLayout_),r)}}this.geometryFunction_=s,this.dragVertexDelay_=t.dragVertexDelay!==void 0?t.dragVertexDelay:500,this.finishCoordinate_=null,this.sketchFeature_=null,this.sketchPoint_=null,this.sketchCoords_=null,this.sketchLine_=null,this.sketchLineCoords_=null,this.squaredClickTolerance_=t.clickTolerance?t.clickTolerance*t.clickTolerance:36,this.overlay_=new It({source:new vt({useSpatialIndex:!1,wrapX:t.wrapX?t.wrapX:!1}),style:t.style?t.style:$t(),updateWhileInteracting:!0}),this.geometryName_=t.geometryName,this.condition_=t.condition?t.condition:At,this.freehandCondition_,t.freehand?this.freehandCondition_=q:this.freehandCondition_=t.freehandCondition?t.freehandCondition:Ot,this.traceCondition_,this.setTrace(t.trace||!1),this.traceState_={active:!1},this.traceSource_=t.traceSource||t.source||null,this.addChangeListener(Nt.ACTIVE,this.updateState_)}setTrace(t){let e;t?t===!0?e=q:e=t:e=Xt,this.traceCondition_=e}setMap(t){super.setMap(t),this.updateState_()}getOverlay(){return this.overlay_}handleEvent(t){t.originalEvent.type===W.CONTEXTMENU&&t.originalEvent.preventDefault(),this.freehand_=this.mode_!=="Point"&&this.freehandCondition_(t);let e=t.type===C.POINTERMOVE,s=!0;return!this.freehand_&&this.lastDragTime_&&t.type===C.POINTERDRAG&&(Date.now()-this.lastDragTime_>=this.dragVertexDelay_?(this.downPx_=t.pixel,this.shouldHandle_=!this.freehand_,e=!0):this.lastDragTime_=void 0,this.shouldHandle_&&this.downTimeout_!==void 0&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0)),this.freehand_&&t.type===C.POINTERDRAG&&this.sketchFeature_!==null?(this.addToDrawing_(t.coordinate),s=!1):this.freehand_&&t.type===C.POINTERDOWN?s=!1:e&&this.getPointerCount()<2?(s=t.type===C.POINTERMOVE,s&&this.freehand_?(this.handlePointerMove_(t),this.shouldHandle_&&t.originalEvent.preventDefault()):(t.originalEvent.pointerType==="mouse"||t.type===C.POINTERDRAG&&this.downTimeout_===void 0)&&this.handlePointerMove_(t)):t.type===C.DBLCLICK&&(s=!1),super.handleEvent(t)&&s}handleDownEvent(t){return this.shouldHandle_=!this.freehand_,this.freehand_?(this.downPx_=t.pixel,this.finishCoordinate_||this.startDrawing_(t.coordinate),!0):this.condition_(t)?(this.lastDragTime_=Date.now(),this.downTimeout_=setTimeout(()=>{this.handlePointerMove_(new jt(C.POINTERMOVE,t.map,t.originalEvent,!1,t.frameState))},this.dragVertexDelay_),this.downPx_=t.pixel,!0):(this.lastDragTime_=void 0,!1)}deactivateTrace_(){this.traceState_={active:!1}}toggleTraceState_(t){if(!this.traceSource_||!this.traceCondition_(t))return;if(this.traceState_.active){this.deactivateTrace_();return}const e=this.getMap(),s=e.getCoordinateFromPixel([t.pixel[0]-this.snapTolerance_,t.pixel[1]+this.snapTolerance_]),i=e.getCoordinateFromPixel([t.pixel[0]+this.snapTolerance_,t.pixel[1]-this.snapTolerance_]),n=B([s,i]),o=this.traceSource_.getFeaturesInExtent(n);if(o.length===0)return;const r=Bt(t.coordinate,o);r.length&&(this.traceState_={active:!0,startPx:t.pixel.slice(),targets:r,targetIndex:-1})}addOrRemoveTracedCoordinates_(t,e){const s=t.startIndex<=t.endIndex,i=t.startIndex<=e;s===i?s&&e>t.endIndex||!s&&e<t.endIndex?this.addTracedCoordinates_(t,t.endIndex,e):(s&&e<t.endIndex||!s&&e>t.endIndex)&&this.removeTracedCoordinates_(e,t.endIndex):(this.removeTracedCoordinates_(t.startIndex,t.endIndex),this.addTracedCoordinates_(t,t.startIndex,e))}removeTracedCoordinates_(t,e){if(t===e)return;let s=0;if(t<e){const i=Math.ceil(t);let n=Math.floor(e);n===e&&(n-=1),s=n-i+1}else{const i=Math.floor(t);let n=Math.ceil(e);n===e&&(n+=1),s=i-n+1}s>0&&this.removeLastPoints_(s)}addTracedCoordinates_(t,e,s){if(e===s)return;const i=[];if(e<s){const n=Math.ceil(e);let o=Math.floor(s);o===s&&(o-=1);for(let r=n;r<=o;++r)i.push(p(t.coordinates,r))}else{const n=Math.floor(e);let o=Math.ceil(s);o===s&&(o+=1);for(let r=n;r>=o;--r)i.push(p(t.coordinates,r))}i.length&&this.appendCoordinates(i)}updateTrace_(t){const e=this.traceState_;if(!e.active||e.targetIndex===-1&&K(e.startPx,t.pixel)<this.snapTolerance_)return;const s=Kt(t.coordinate,e,this.getMap(),this.snapTolerance_);if(e.targetIndex!==s.index){if(e.targetIndex!==-1){const a=e.targets[e.targetIndex];this.removeTracedCoordinates_(a.startIndex,a.endIndex)}const r=e.targets[s.index];this.addTracedCoordinates_(r,r.startIndex,s.endIndex)}else{const r=e.targets[e.targetIndex];this.addOrRemoveTracedCoordinates_(r,s.endIndex)}e.targetIndex=s.index;const i=e.targets[e.targetIndex];i.endIndex=s.endIndex;const n=y(i.coordinates,i.endIndex),o=this.getMap().getPixelFromCoordinate(n);t.coordinate=n,t.pixel=[Math.round(o[0]),Math.round(o[1])]}handleUpEvent(t){let e=!0;if(this.getPointerCount()===0){this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0),this.handlePointerMove_(t);const s=this.traceState_.active;if(this.toggleTraceState_(t),this.shouldHandle_){const i=!this.finishCoordinate_;i&&this.startDrawing_(t.coordinate),!i&&this.freehand_?this.finishDrawing():!this.freehand_&&(!i||this.mode_==="Point")&&(this.atFinish_(t.pixel,s)?this.finishCondition_(t)&&this.finishDrawing():this.addToDrawing_(t.coordinate)),e=!1}else this.freehand_&&this.abortDrawing()}return!e&&this.stopClick_&&t.preventDefault(),e}handlePointerMove_(t){if(this.pointerType_=t.originalEvent.pointerType,this.downPx_&&(!this.freehand_&&this.shouldHandle_||this.freehand_&&!this.shouldHandle_)){const e=this.downPx_,s=t.pixel,i=e[0]-s[0],n=e[1]-s[1],o=i*i+n*n;if(this.shouldHandle_=this.freehand_?o>this.squaredClickTolerance_:o<=this.squaredClickTolerance_,!this.shouldHandle_)return}if(!this.finishCoordinate_){this.createOrUpdateSketchPoint_(t.coordinate.slice());return}this.updateTrace_(t),this.modifyDrawing_(t.coordinate)}atFinish_(t,e){let s=!1;if(this.sketchFeature_){let i=!1,n=[this.finishCoordinate_];const o=this.mode_;if(o==="Point")s=!0;else if(o==="Circle")s=this.sketchCoords_.length===2;else if(o==="LineString")i=!e&&this.sketchCoords_.length>this.minPoints_;else if(o==="Polygon"){const r=this.sketchCoords_;i=r[0].length>this.minPoints_,n=[r[0][0],r[0][r[0].length-2]],e?n=[r[0][0]]:n=[r[0][0],r[0][r[0].length-2]]}if(i){const r=this.getMap();for(let a=0,l=n.length;a<l;a++){const c=n[a],d=r.getPixelFromCoordinate(c),f=t[0]-d[0],g=t[1]-d[1],u=this.freehand_?1:this.snapTolerance_;if(s=Math.sqrt(f*f+g*g)<=u,s){this.finishCoordinate_=c;break}}}}return s}createOrUpdateSketchPoint_(t){this.sketchPoint_?this.sketchPoint_.getGeometry().setCoordinates(t):(this.sketchPoint_=new k(new T(t)),this.updateSketchFeatures_())}createOrUpdateCustomSketchLine_(t){this.sketchLine_||(this.sketchLine_=new k);const e=t.getLinearRing(0);let s=this.sketchLine_.getGeometry();s?(s.setFlatCoordinates(e.getLayout(),e.getFlatCoordinates()),s.changed()):(s=new w(e.getFlatCoordinates(),e.getLayout()),this.sketchLine_.setGeometry(s))}startDrawing_(t){const e=this.getMap().getView().getProjection(),s=b(this.geometryLayout_);for(;t.length<s;)t.push(0);this.finishCoordinate_=t,this.mode_==="Point"?this.sketchCoords_=t.slice():this.mode_==="Polygon"?(this.sketchCoords_=[[t.slice(),t.slice()]],this.sketchLineCoords_=this.sketchCoords_[0]):this.sketchCoords_=[t.slice(),t.slice()],this.sketchLineCoords_&&(this.sketchLine_=new k(new w(this.sketchLineCoords_)));const i=this.geometryFunction_(this.sketchCoords_,void 0,e);this.sketchFeature_=new k,this.geometryName_&&this.sketchFeature_.setGeometryName(this.geometryName_),this.sketchFeature_.setGeometry(i),this.updateSketchFeatures_(),this.dispatchEvent(new E(L.DRAWSTART,this.sketchFeature_))}modifyDrawing_(t){const e=this.getMap(),s=this.sketchFeature_.getGeometry(),i=e.getView().getProjection(),n=b(this.geometryLayout_);let o,r;for(;t.length<n;)t.push(0);this.mode_==="Point"?r=this.sketchCoords_:this.mode_==="Polygon"?(o=this.sketchCoords_[0],r=o[o.length-1],this.atFinish_(e.getPixelFromCoordinate(t))&&(t=this.finishCoordinate_.slice())):(o=this.sketchCoords_,r=o[o.length-1]),r[0]=t[0],r[1]=t[1],this.geometryFunction_(this.sketchCoords_,s,i),this.sketchPoint_&&this.sketchPoint_.getGeometry().setCoordinates(t),s.getType()==="Polygon"&&this.mode_!=="Polygon"?this.createOrUpdateCustomSketchLine_(s):this.sketchLineCoords_&&this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_),this.updateSketchFeatures_()}addToDrawing_(t){const e=this.sketchFeature_.getGeometry(),s=this.getMap().getView().getProjection();let i,n;const o=this.mode_;return o==="LineString"||o==="Circle"?(this.finishCoordinate_=t.slice(),n=this.sketchCoords_,n.length>=this.maxPoints_&&(this.freehand_?n.pop():i=!0),n.push(t.slice()),this.geometryFunction_(n,e,s)):o==="Polygon"&&(n=this.sketchCoords_[0],n.length>=this.maxPoints_&&(this.freehand_?n.pop():i=!0),n.push(t.slice()),i&&(this.finishCoordinate_=n[0]),this.geometryFunction_(this.sketchCoords_,e,s)),this.createOrUpdateSketchPoint_(t.slice()),this.updateSketchFeatures_(),i?this.finishDrawing():this.sketchFeature_}removeLastPoints_(t){if(!this.sketchFeature_)return;const e=this.sketchFeature_.getGeometry(),s=this.getMap().getView().getProjection(),i=this.mode_;for(let n=0;n<t;++n){let o;if(i==="LineString"||i==="Circle"){if(o=this.sketchCoords_,o.splice(-2,1),o.length>=2){this.finishCoordinate_=o[o.length-2].slice();const r=this.finishCoordinate_.slice();o[o.length-1]=r,this.createOrUpdateSketchPoint_(r)}this.geometryFunction_(o,e,s),e.getType()==="Polygon"&&this.sketchLine_&&this.createOrUpdateCustomSketchLine_(e)}else if(i==="Polygon"){o=this.sketchCoords_[0],o.splice(-2,1);const r=this.sketchLine_.getGeometry();if(o.length>=2){const a=o[o.length-2].slice();o[o.length-1]=a,this.createOrUpdateSketchPoint_(a)}r.setCoordinates(o),this.geometryFunction_(this.sketchCoords_,e,s)}if(o.length===1){this.abortDrawing();break}}this.updateSketchFeatures_()}removeLastPoint(){this.removeLastPoints_(1)}finishDrawing(){const t=this.abortDrawing_();if(!t)return null;let e=this.sketchCoords_;const s=t.getGeometry(),i=this.getMap().getView().getProjection();return this.mode_==="LineString"?(e.pop(),this.geometryFunction_(e,s,i)):this.mode_==="Polygon"&&(e[0].pop(),this.geometryFunction_(e,s,i),e=s.getCoordinates()),this.type_==="MultiPoint"?t.setGeometry(new v([e])):this.type_==="MultiLineString"?t.setGeometry(new F([e])):this.type_==="MultiPolygon"&&t.setGeometry(new D([e])),this.dispatchEvent(new E(L.DRAWEND,t)),this.features_&&this.features_.push(t),this.source_&&this.source_.addFeature(t),t}abortDrawing_(){this.finishCoordinate_=null;const t=this.sketchFeature_;return this.sketchFeature_=null,this.sketchPoint_=null,this.sketchLine_=null,this.overlay_.getSource().clear(!0),this.deactivateTrace_(),t}abortDrawing(){const t=this.abortDrawing_();t&&this.dispatchEvent(new E(L.DRAWABORT,t))}appendCoordinates(t){const e=this.mode_,s=!this.sketchFeature_;s&&this.startDrawing_(t[0]);let i;if(e==="LineString"||e==="Circle")i=this.sketchCoords_;else if(e==="Polygon")i=this.sketchCoords_&&this.sketchCoords_.length?this.sketchCoords_[0]:[];else return;s&&i.shift(),i.pop();for(let o=0;o<t.length;o++)this.addToDrawing_(t[o]);const n=t[t.length-1];this.sketchFeature_=this.addToDrawing_(n),this.modifyDrawing_(n)}extend(t){const s=t.getGeometry();this.sketchFeature_=t,this.sketchCoords_=s.getCoordinates();const i=this.sketchCoords_[this.sketchCoords_.length-1];this.finishCoordinate_=i.slice(),this.sketchCoords_.push(i.slice()),this.sketchPoint_=new k(new T(i)),this.updateSketchFeatures_(),this.dispatchEvent(new E(L.DRAWSTART,this.sketchFeature_))}updateSketchFeatures_(){const t=[];this.sketchFeature_&&t.push(this.sketchFeature_),this.sketchLine_&&t.push(this.sketchLine_),this.sketchPoint_&&t.push(this.sketchPoint_);const e=this.overlay_.getSource();e.clear(!0),e.addFeatures(t)}updateState_(){const t=this.getMap(),e=this.getActive();(!t||!e)&&this.abortDrawing(),this.overlay_.setMap(e?t:null)}}function $t(){const h=Yt();return function(t,e){return h[t.getGeometry().getType()]}}function Qt(){return function(h,t,e){const s=B([h[0],h[h.length-1]].map(function(n){return X(n)})),i=[[H(s),qt(s),bt(s),Ht(s),H(s)]];return t?t.setCoordinates(i):t=new x(i),t}}function zt(h){switch(h){case"Point":case"MultiPoint":return"Point";case"LineString":case"MultiLineString":return"LineString";case"Polygon":case"MultiPolygon":return"Polygon";case"Circle":return"Circle";default:throw new Error("Invalid type: "+h)}}export{Jt as D,Qt as c};
