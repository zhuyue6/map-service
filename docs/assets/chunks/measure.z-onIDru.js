import{G as We,u as Ge,l as be,E as z,b as ie,d as Ke,e as $e,f as ze,S as _e,h as M,i as Je,j as Qe,k as Ze,m as et,L as b,n as tt,o as it,p as st,q as nt,r as rt,s as me,t as ot,P as k,v as at,w as lt,x as ht,y as dt,z as ct,A as ut,B as xe,C as gt,D as ft,F as _t,H as mt,I as yt,J as N,K as pt,M as Ct,N as ye,O as xt,T as V,Q as Pt,R as y,U as J,V as U,W as se,X as Ft,Y as Q,Z as Re,_ as Oe,$ as P,a0 as Tt,a1 as x,a2 as Z,a3 as v,a4 as Pe,a5 as fe,a6 as pe,a7 as ne,a8 as Et,a9 as Fe,aa as St,ab as vt,ac as wt,ad as Mt,ae as X,g as Lt,af as L,ag as Ne,ah as kt,ai as Ve,aj as F,ak as D,al as It,am as Dt,an as Te,ao as At,ap as Gt,aq as bt,ar as Rt,as as Ot,at as Ee,au as oe,av as E,aw as ee,ax as Nt,ay as Vt,az as Bt,aA as jt,aB as Ut,aC as Xt,aD as Ht,aE as Yt,aF as qt,aG as Wt,aH as Kt,aI as $t,aJ as zt,aK as Se,aL as Jt,aM as Qt,aN as ve,aO as we,aP as Zt,aQ as ei}from"./index.DAxF4nnB.js";class te extends We{constructor(e){super(),this.geometries_=e,this.changeEventsKeys_=[],this.listenGeometriesChange_()}unlistenGeometriesChange_(){this.changeEventsKeys_.forEach(Ge),this.changeEventsKeys_.length=0}listenGeometriesChange_(){const e=this.geometries_;for(let t=0,i=e.length;t<i;++t)this.changeEventsKeys_.push(be(e[t],z.CHANGE,this.changed,this))}clone(){const e=new te(ae(this.geometries_));return e.applyProperties(this),e}closestPointXY(e,t,i,s){if(s<ie(this.getExtent(),e,t))return s;const n=this.geometries_;for(let r=0,o=n.length;r<o;++r)s=n[r].closestPointXY(e,t,i,s);return s}containsXY(e,t){const i=this.geometries_;for(let s=0,n=i.length;s<n;++s)if(i[s].containsXY(e,t))return!0;return!1}computeExtent(e){Ke(e);const t=this.geometries_;for(let i=0,s=t.length;i<s;++i)$e(e,t[i].getExtent());return e}getGeometries(){return ae(this.geometries_)}getGeometriesArray(){return this.geometries_}getGeometriesArrayRecursive(){let e=[];const t=this.geometries_;for(let i=0,s=t.length;i<s;++i)t[i].getType()===this.getType()?e=e.concat(t[i].getGeometriesArrayRecursive()):e.push(t[i]);return e}getSimplifiedGeometry(e){if(this.simplifiedGeometryRevision!==this.getRevision()&&(this.simplifiedGeometryMaxMinSquaredTolerance=0,this.simplifiedGeometryRevision=this.getRevision()),e<0||this.simplifiedGeometryMaxMinSquaredTolerance!==0&&e<this.simplifiedGeometryMaxMinSquaredTolerance)return this;const t=[],i=this.geometries_;let s=!1;for(let n=0,r=i.length;n<r;++n){const o=i[n],a=o.getSimplifiedGeometry(e);t.push(a),a!==o&&(s=!0)}return s?new te(t):(this.simplifiedGeometryMaxMinSquaredTolerance=e,this)}getType(){return"GeometryCollection"}intersectsExtent(e){const t=this.geometries_;for(let i=0,s=t.length;i<s;++i)if(t[i].intersectsExtent(e))return!0;return!1}isEmpty(){return this.geometries_.length===0}rotate(e,t){const i=this.geometries_;for(let s=0,n=i.length;s<n;++s)i[s].rotate(e,t);this.changed()}scale(e,t,i){i||(i=ze(this.getExtent()));const s=this.geometries_;for(let n=0,r=s.length;n<r;++n)s[n].scale(e,t,i);this.changed()}setGeometries(e){this.setGeometriesArray(ae(e))}setGeometriesArray(e){this.unlistenGeometriesChange_(),this.geometries_=e,this.listenGeometriesChange_(),this.changed()}applyTransform(e){const t=this.geometries_;for(let i=0,s=t.length;i<s;++i)t[i].applyTransform(e);this.changed()}translate(e,t){const i=this.geometries_;for(let s=0,n=i.length;s<n;++s)i[s].translate(e,t);this.changed()}disposeInternal(){this.unlistenGeometriesChange_(),super.disposeInternal()}}function ae(d){return d.map(e=>e.clone())}class B extends _e{constructor(e,t,i){if(super(),this.ends_=[],this.maxDelta_=-1,this.maxDeltaRevision_=-1,Array.isArray(e[0]))this.setCoordinates(e,t);else if(t!==void 0&&i)this.setFlatCoordinates(t,e),this.ends_=i;else{const s=e,n=[],r=[];for(let a=0,h=s.length;a<h;++a){const l=s[a];M(n,l.getFlatCoordinates()),r.push(n.length)}const o=s.length===0?this.getLayout():s[0].getLayout();this.setFlatCoordinates(o,n),this.ends_=r}}appendLineString(e){M(this.flatCoordinates,e.getFlatCoordinates().slice()),this.ends_.push(this.flatCoordinates.length),this.changed()}clone(){const e=new B(this.flatCoordinates.slice(),this.layout,this.ends_.slice());return e.applyProperties(this),e}closestPointXY(e,t,i,s){return s<ie(this.getExtent(),e,t)?s:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(Je(this.flatCoordinates,0,this.ends_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),Qe(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,!1,e,t,i,s))}getCoordinateAtM(e,t,i){return this.layout!="XYM"&&this.layout!="XYZM"||this.flatCoordinates.length===0?null:(t=t!==void 0?t:!1,i=i!==void 0?i:!1,Ze(this.flatCoordinates,0,this.ends_,this.stride,e,t,i))}getCoordinates(){return et(this.flatCoordinates,0,this.ends_,this.stride)}getEnds(){return this.ends_}getLineString(e){return e<0||this.ends_.length<=e?null:new b(this.flatCoordinates.slice(e===0?0:this.ends_[e-1],this.ends_[e]),this.layout)}getLineStrings(){const e=this.flatCoordinates,t=this.ends_,i=this.layout,s=[];let n=0;for(let r=0,o=t.length;r<o;++r){const a=t[r],h=new b(e.slice(n,a),i);s.push(h),n=a}return s}getLength(){const e=this.ends_;let t=0,i=0;for(let s=0,n=e.length;s<n;++s)i+=tt(this.flatCoordinates,t,e[s],this.stride),t=e[s];return i}getFlatMidpoints(){const e=[],t=this.flatCoordinates;let i=0;const s=this.ends_,n=this.stride;for(let r=0,o=s.length;r<o;++r){const a=s[r],h=it(t,i,a,n,.5);M(e,h),i=a}return e}getSimplifiedGeometryInternal(e){const t=[],i=[];return t.length=st(this.flatCoordinates,0,this.ends_,this.stride,e,t,0,i),new B(t,"XY",i)}getType(){return"MultiLineString"}intersectsExtent(e){return nt(this.flatCoordinates,0,this.ends_,this.stride,e)}setCoordinates(e,t){this.setLayout(t,e,2),this.flatCoordinates||(this.flatCoordinates=[]);const i=rt(this.flatCoordinates,0,e,this.stride,this.ends_);this.flatCoordinates.length=i.length===0?0:i[i.length-1],this.changed()}}class re extends _e{constructor(e,t){super(),t&&!Array.isArray(e[0])?this.setFlatCoordinates(t,e):this.setCoordinates(e,t)}appendPoint(e){M(this.flatCoordinates,e.getFlatCoordinates()),this.changed()}clone(){const e=new re(this.flatCoordinates.slice(),this.layout);return e.applyProperties(this),e}closestPointXY(e,t,i,s){if(s<ie(this.getExtent(),e,t))return s;const n=this.flatCoordinates,r=this.stride;for(let o=0,a=n.length;o<a;o+=r){const h=me(e,t,n[o],n[o+1]);if(h<s){s=h;for(let l=0;l<r;++l)i[l]=n[o+l];i.length=r}}return s}getCoordinates(){return ot(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)}getPoint(e){const t=this.flatCoordinates.length/this.stride;return e<0||t<=e?null:new k(this.flatCoordinates.slice(e*this.stride,(e+1)*this.stride),this.layout)}getPoints(){const e=this.flatCoordinates,t=this.layout,i=this.stride,s=[];for(let n=0,r=e.length;n<r;n+=i){const o=new k(e.slice(n,n+i),t);s.push(o)}return s}getType(){return"MultiPoint"}intersectsExtent(e){const t=this.flatCoordinates,i=this.stride;for(let s=0,n=t.length;s<n;s+=i){const r=t[s],o=t[s+1];if(at(e,r,o))return!0}return!1}setCoordinates(e,t){this.setLayout(t,e,1),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=lt(this.flatCoordinates,0,e,this.stride),this.changed()}}class j extends _e{constructor(e,t,i){if(super(),this.endss_=[],this.flatInteriorPointsRevision_=-1,this.flatInteriorPoints_=null,this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.orientedRevision_=-1,this.orientedFlatCoordinates_=null,!i&&!Array.isArray(e[0])){const s=e,n=[],r=[];for(let o=0,a=s.length;o<a;++o){const h=s[o],l=n.length,c=h.getEnds();for(let u=0,g=c.length;u<g;++u)c[u]+=l;M(n,h.getFlatCoordinates()),r.push(c)}t=s.length===0?this.getLayout():s[0].getLayout(),e=n,i=r}t!==void 0&&i?(this.setFlatCoordinates(t,e),this.endss_=i):this.setCoordinates(e,t)}appendPolygon(e){let t;if(!this.flatCoordinates)this.flatCoordinates=e.getFlatCoordinates().slice(),t=e.getEnds().slice(),this.endss_.push();else{const i=this.flatCoordinates.length;M(this.flatCoordinates,e.getFlatCoordinates()),t=e.getEnds().slice();for(let s=0,n=t.length;s<n;++s)t[s]+=i}this.endss_.push(t),this.changed()}clone(){const e=this.endss_.length,t=new Array(e);for(let s=0;s<e;++s)t[s]=this.endss_[s].slice();const i=new j(this.flatCoordinates.slice(),this.layout,t);return i.applyProperties(this),i}closestPointXY(e,t,i,s){return s<ie(this.getExtent(),e,t)?s:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(ht(this.flatCoordinates,0,this.endss_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),dt(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,this.maxDelta_,!0,e,t,i,s))}containsXY(e,t){return ct(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,e,t)}getArea(){return ut(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride)}getCoordinates(e){let t;return e!==void 0?(t=this.getOrientedFlatCoordinates().slice(),xe(t,0,this.endss_,this.stride,e)):t=this.flatCoordinates,gt(t,0,this.endss_,this.stride)}getEndss(){return this.endss_}getFlatInteriorPoints(){if(this.flatInteriorPointsRevision_!=this.getRevision()){const e=ft(this.flatCoordinates,0,this.endss_,this.stride);this.flatInteriorPoints_=_t(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,e),this.flatInteriorPointsRevision_=this.getRevision()}return this.flatInteriorPoints_}getInteriorPoints(){return new re(this.getFlatInteriorPoints().slice(),"XYM")}getOrientedFlatCoordinates(){if(this.orientedRevision_!=this.getRevision()){const e=this.flatCoordinates;mt(e,0,this.endss_,this.stride)?this.orientedFlatCoordinates_=e:(this.orientedFlatCoordinates_=e.slice(),this.orientedFlatCoordinates_.length=xe(this.orientedFlatCoordinates_,0,this.endss_,this.stride)),this.orientedRevision_=this.getRevision()}return this.orientedFlatCoordinates_}getSimplifiedGeometryInternal(e){const t=[],i=[];return t.length=yt(this.flatCoordinates,0,this.endss_,this.stride,Math.sqrt(e),t,0,i),new j(t,"XY",i)}getPolygon(e){if(e<0||this.endss_.length<=e)return null;let t;if(e===0)t=0;else{const n=this.endss_[e-1];t=n[n.length-1]}const i=this.endss_[e].slice(),s=i[i.length-1];if(t!==0)for(let n=0,r=i.length;n<r;++n)i[n]-=t;return new N(this.flatCoordinates.slice(t,s),this.layout,i)}getPolygons(){const e=this.layout,t=this.flatCoordinates,i=this.endss_,s=[];let n=0;for(let r=0,o=i.length;r<o;++r){const a=i[r].slice(),h=a[a.length-1];if(n!==0)for(let c=0,u=a.length;c<u;++c)a[c]-=n;const l=new N(t.slice(n,h),e,a);s.push(l),n=h}return s}getType(){return"MultiPolygon"}intersectsExtent(e){return pt(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,e)}setCoordinates(e,t){this.setLayout(t,e,3),this.flatCoordinates||(this.flatCoordinates=[]);const i=Ct(this.flatCoordinates,0,e,this.stride,this.endss_);if(i.length===0)this.flatCoordinates.length=0;else{const s=i[i.length-1];this.flatCoordinates.length=s.length===0?0:s[s.length-1]}this.changed()}}const H={DRAWSTART:"drawstart",DRAWEND:"drawend",DRAWABORT:"drawabort"};class Y extends ne{constructor(e,t){super(e),this.feature=t}}function ti(d,e){const t=[];for(let i=0;i<e.length;++i){const n=e[i].getGeometry();Be(d,n,t)}return t}function q(d,e){return me(d[0],d[1],e[0],e[1])}function A(d,e){const t=d.length;return e<0?d[e+t]:e>=t?d[e-t]:d[e]}function W(d,e,t){let i,s;e<t?(i=e,s=t):(i=t,s=e);const n=Math.ceil(i),r=Math.floor(s);if(n>r){const a=G(d,i),h=G(d,s);return q(a,h)}let o=0;if(i<n){const a=G(d,i),h=A(d,n);o+=q(a,h)}if(r<s){const a=A(d,r),h=G(d,s);o+=q(a,h)}for(let a=n;a<r-1;++a){const h=A(d,a),l=A(d,a+1);o+=q(h,l)}return o}function Be(d,e,t){if(e instanceof b){K(d,e.getCoordinates(),!1,t);return}if(e instanceof B){const i=e.getCoordinates();for(let s=0,n=i.length;s<n;++s)K(d,i[s],!1,t);return}if(e instanceof N){const i=e.getCoordinates();for(let s=0,n=i.length;s<n;++s)K(d,i[s],!0,t);return}if(e instanceof j){const i=e.getCoordinates();for(let s=0,n=i.length;s<n;++s){const r=i[s];for(let o=0,a=r.length;o<a;++o)K(d,r[o],!0,t)}return}if(e instanceof te){const i=e.getGeometries();for(let s=0;s<i.length;++s)Be(d,i[s],t);return}}const le={index:-1,endIndex:NaN};function ii(d,e,t,i){const s=d[0],n=d[1];let r=1/0,o=-1,a=NaN;for(let c=0;c<e.targets.length;++c){const u=e.targets[c],g=u.coordinates;let f=1/0,_;for(let m=0;m<g.length-1;++m){const C=g[m],T=g[m+1],S=je(s,n,C,T);S.squaredDistance<f&&(f=S.squaredDistance,_=m+S.along)}f<r&&(r=f,u.ring&&e.targetIndex===c&&(u.endIndex>u.startIndex?_<u.startIndex&&(_+=g.length):u.endIndex<u.startIndex&&_>u.startIndex&&(_-=g.length)),a=_,o=c)}const h=e.targets[o];let l=h.ring;if(e.targetIndex===o&&l){const c=G(h.coordinates,a),u=t.getPixelFromCoordinate(c);Z(u,e.startPx)>i&&(l=!1)}if(l){const c=h.coordinates,u=c.length,g=h.startIndex,f=a;if(g<f){const _=W(c,g,f);W(c,g,f-u)<_&&(a-=u)}else{const _=W(c,g,f);W(c,g,f+u)<_&&(a+=u)}}return le.index=o,le.endIndex=a,le}function K(d,e,t,i){const s=d[0],n=d[1];for(let r=0,o=e.length-1;r<o;++r){const a=e[r],h=e[r+1],l=je(s,n,a,h);if(l.squaredDistance===0){const c=r+l.along;i.push({coordinates:e,ring:t,startIndex:c,endIndex:c});return}}}const he={along:0,squaredDistance:0};function je(d,e,t,i){const s=t[0],n=t[1],r=i[0],o=i[1],a=r-s,h=o-n;let l=0,c=s,u=n;return(a!==0||h!==0)&&(l=Mt(((d-s)*a+(e-n)*h)/(a*a+h*h),0,1),c+=a*l,u+=h*l),he.along=l,he.squaredDistance=Et(me(d,e,c,u),10),he}function G(d,e){const t=d.length;let i=Math.floor(e);const s=e-i;i>=t?i-=t:i<0&&(i+=t);let n=i+1;n>=t&&(n-=t);const r=d[i],o=r[0],a=r[1],h=d[n],l=h[0]-o,c=h[1]-a;return[o+l*s,a+c*s]}class Ue extends ye{constructor(e){const t=e;t.stopDown||(t.stopDown=xt),super(t),this.on,this.once,this.un,this.shouldHandle_=!1,this.downPx_=null,this.downTimeout_,this.lastDragTime_,this.pointerType_,this.freehand_=!1,this.source_=e.source?e.source:null,this.features_=e.features?e.features:null,this.snapTolerance_=e.snapTolerance?e.snapTolerance:12,this.type_=e.type,this.mode_=ri(this.type_),this.stopClick_=!!e.stopClick,this.minPoints_=e.minPoints?e.minPoints:this.mode_==="Polygon"?3:2,this.maxPoints_=this.mode_==="Circle"?2:e.maxPoints?e.maxPoints:1/0,this.finishCondition_=e.finishCondition?e.finishCondition:V,this.geometryLayout_=e.geometryLayout?e.geometryLayout:"XY";let i=e.geometryFunction;if(!i){const s=this.mode_;if(s==="Circle")i=(n,r,o)=>{const a=r||new Pt([NaN,NaN]),h=y(n[0]),l=J(h,y(n[n.length-1]));return a.setCenterAndRadius(h,Math.sqrt(l),this.geometryLayout_),a};else{let n;s==="Point"?n=k:s==="LineString"?n=b:s==="Polygon"&&(n=N),i=(r,o,a)=>(o?s==="Polygon"?r[0].length?o.setCoordinates([r[0].concat([r[0][0]])],this.geometryLayout_):o.setCoordinates([],this.geometryLayout_):o.setCoordinates(r,this.geometryLayout_):o=new n(r,this.geometryLayout_),o)}}this.geometryFunction_=i,this.dragVertexDelay_=e.dragVertexDelay!==void 0?e.dragVertexDelay:500,this.finishCoordinate_=null,this.sketchFeature_=null,this.sketchPoint_=null,this.sketchCoords_=null,this.sketchLine_=null,this.sketchLineCoords_=null,this.squaredClickTolerance_=e.clickTolerance?e.clickTolerance*e.clickTolerance:36,this.overlay_=new U({source:new se({useSpatialIndex:!1,wrapX:e.wrapX?e.wrapX:!1}),style:e.style?e.style:si(),updateWhileInteracting:!0}),this.geometryName_=e.geometryName,this.condition_=e.condition?e.condition:Ft,this.freehandCondition_,e.freehand?this.freehandCondition_=Q:this.freehandCondition_=e.freehandCondition?e.freehandCondition:Re,this.traceCondition_,this.setTrace(e.trace||!1),this.traceState_={active:!1},this.traceSource_=e.traceSource||e.source||null,this.addChangeListener(Oe.ACTIVE,this.updateState_)}setTrace(e){let t;e?e===!0?t=Q:t=e:t=fe,this.traceCondition_=t}setMap(e){super.setMap(e),this.updateState_()}getOverlay(){return this.overlay_}handleEvent(e){e.originalEvent.type===z.CONTEXTMENU&&e.originalEvent.preventDefault(),this.freehand_=this.mode_!=="Point"&&this.freehandCondition_(e);let t=e.type===P.POINTERMOVE,i=!0;return!this.freehand_&&this.lastDragTime_&&e.type===P.POINTERDRAG&&(Date.now()-this.lastDragTime_>=this.dragVertexDelay_?(this.downPx_=e.pixel,this.shouldHandle_=!this.freehand_,t=!0):this.lastDragTime_=void 0,this.shouldHandle_&&this.downTimeout_!==void 0&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0)),this.freehand_&&e.type===P.POINTERDRAG&&this.sketchFeature_!==null?(this.addToDrawing_(e.coordinate),i=!1):this.freehand_&&e.type===P.POINTERDOWN?i=!1:t&&this.getPointerCount()<2?(i=e.type===P.POINTERMOVE,i&&this.freehand_?(this.handlePointerMove_(e),this.shouldHandle_&&e.originalEvent.preventDefault()):(e.originalEvent.pointerType==="mouse"||e.type===P.POINTERDRAG&&this.downTimeout_===void 0)&&this.handlePointerMove_(e)):e.type===P.DBLCLICK&&(i=!1),super.handleEvent(e)&&i}handleDownEvent(e){return this.shouldHandle_=!this.freehand_,this.freehand_?(this.downPx_=e.pixel,this.finishCoordinate_||this.startDrawing_(e.coordinate),!0):this.condition_(e)?(this.lastDragTime_=Date.now(),this.downTimeout_=setTimeout(()=>{this.handlePointerMove_(new Tt(P.POINTERMOVE,e.map,e.originalEvent,!1,e.frameState))},this.dragVertexDelay_),this.downPx_=e.pixel,!0):(this.lastDragTime_=void 0,!1)}deactivateTrace_(){this.traceState_={active:!1}}toggleTraceState_(e){if(!this.traceSource_||!this.traceCondition_(e))return;if(this.traceState_.active){this.deactivateTrace_();return}const t=this.getMap(),i=t.getCoordinateFromPixel([e.pixel[0]-this.snapTolerance_,e.pixel[1]+this.snapTolerance_]),s=t.getCoordinateFromPixel([e.pixel[0]+this.snapTolerance_,e.pixel[1]-this.snapTolerance_]),n=x([i,s]),r=this.traceSource_.getFeaturesInExtent(n);if(r.length===0)return;const o=ti(e.coordinate,r);o.length&&(this.traceState_={active:!0,startPx:e.pixel.slice(),targets:o,targetIndex:-1})}addOrRemoveTracedCoordinates_(e,t){const i=e.startIndex<=e.endIndex,s=e.startIndex<=t;i===s?i&&t>e.endIndex||!i&&t<e.endIndex?this.addTracedCoordinates_(e,e.endIndex,t):(i&&t<e.endIndex||!i&&t>e.endIndex)&&this.removeTracedCoordinates_(t,e.endIndex):(this.removeTracedCoordinates_(e.startIndex,e.endIndex),this.addTracedCoordinates_(e,e.startIndex,t))}removeTracedCoordinates_(e,t){if(e===t)return;let i=0;if(e<t){const s=Math.ceil(e);let n=Math.floor(t);n===t&&(n-=1),i=n-s+1}else{const s=Math.floor(e);let n=Math.ceil(t);n===t&&(n+=1),i=s-n+1}i>0&&this.removeLastPoints_(i)}addTracedCoordinates_(e,t,i){if(t===i)return;const s=[];if(t<i){const n=Math.ceil(t);let r=Math.floor(i);r===i&&(r-=1);for(let o=n;o<=r;++o)s.push(A(e.coordinates,o))}else{const n=Math.floor(t);let r=Math.ceil(i);r===i&&(r+=1);for(let o=n;o>=r;--o)s.push(A(e.coordinates,o))}s.length&&this.appendCoordinates(s)}updateTrace_(e){const t=this.traceState_;if(!t.active||t.targetIndex===-1&&Z(t.startPx,e.pixel)<this.snapTolerance_)return;const i=ii(e.coordinate,t,this.getMap(),this.snapTolerance_);if(t.targetIndex!==i.index){if(t.targetIndex!==-1){const a=t.targets[t.targetIndex];this.removeTracedCoordinates_(a.startIndex,a.endIndex)}const o=t.targets[i.index];this.addTracedCoordinates_(o,o.startIndex,i.endIndex)}else{const o=t.targets[t.targetIndex];this.addOrRemoveTracedCoordinates_(o,i.endIndex)}t.targetIndex=i.index;const s=t.targets[t.targetIndex];s.endIndex=i.endIndex;const n=G(s.coordinates,s.endIndex),r=this.getMap().getPixelFromCoordinate(n);e.coordinate=n,e.pixel=[Math.round(r[0]),Math.round(r[1])]}handleUpEvent(e){let t=!0;if(this.getPointerCount()===0){this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0),this.handlePointerMove_(e);const i=this.traceState_.active;if(this.toggleTraceState_(e),this.shouldHandle_){const s=!this.finishCoordinate_;s&&this.startDrawing_(e.coordinate),!s&&this.freehand_?this.finishDrawing():!this.freehand_&&(!s||this.mode_==="Point")&&(this.atFinish_(e.pixel,i)?this.finishCondition_(e)&&this.finishDrawing():this.addToDrawing_(e.coordinate)),t=!1}else this.freehand_&&this.abortDrawing()}return!t&&this.stopClick_&&e.preventDefault(),t}handlePointerMove_(e){if(this.pointerType_=e.originalEvent.pointerType,this.downPx_&&(!this.freehand_&&this.shouldHandle_||this.freehand_&&!this.shouldHandle_)){const t=this.downPx_,i=e.pixel,s=t[0]-i[0],n=t[1]-i[1],r=s*s+n*n;if(this.shouldHandle_=this.freehand_?r>this.squaredClickTolerance_:r<=this.squaredClickTolerance_,!this.shouldHandle_)return}if(!this.finishCoordinate_){this.createOrUpdateSketchPoint_(e.coordinate.slice());return}this.updateTrace_(e),this.modifyDrawing_(e.coordinate)}atFinish_(e,t){let i=!1;if(this.sketchFeature_){let s=!1,n=[this.finishCoordinate_];const r=this.mode_;if(r==="Point")i=!0;else if(r==="Circle")i=this.sketchCoords_.length===2;else if(r==="LineString")s=!t&&this.sketchCoords_.length>this.minPoints_;else if(r==="Polygon"){const o=this.sketchCoords_;s=o[0].length>this.minPoints_,n=[o[0][0],o[0][o[0].length-2]],t?n=[o[0][0]]:n=[o[0][0],o[0][o[0].length-2]]}if(s){const o=this.getMap();for(let a=0,h=n.length;a<h;a++){const l=n[a],c=o.getPixelFromCoordinate(l),u=e[0]-c[0],g=e[1]-c[1],f=this.freehand_?1:this.snapTolerance_;if(i=Math.sqrt(u*u+g*g)<=f,i){this.finishCoordinate_=l;break}}}}return i}createOrUpdateSketchPoint_(e){this.sketchPoint_?this.sketchPoint_.getGeometry().setCoordinates(e):(this.sketchPoint_=new v(new k(e)),this.updateSketchFeatures_())}createOrUpdateCustomSketchLine_(e){this.sketchLine_||(this.sketchLine_=new v);const t=e.getLinearRing(0);let i=this.sketchLine_.getGeometry();i?(i.setFlatCoordinates(t.getLayout(),t.getFlatCoordinates()),i.changed()):(i=new b(t.getFlatCoordinates(),t.getLayout()),this.sketchLine_.setGeometry(i))}startDrawing_(e){const t=this.getMap().getView().getProjection(),i=Pe(this.geometryLayout_);for(;e.length<i;)e.push(0);this.finishCoordinate_=e,this.mode_==="Point"?this.sketchCoords_=e.slice():this.mode_==="Polygon"?(this.sketchCoords_=[[e.slice(),e.slice()]],this.sketchLineCoords_=this.sketchCoords_[0]):this.sketchCoords_=[e.slice(),e.slice()],this.sketchLineCoords_&&(this.sketchLine_=new v(new b(this.sketchLineCoords_)));const s=this.geometryFunction_(this.sketchCoords_,void 0,t);this.sketchFeature_=new v,this.geometryName_&&this.sketchFeature_.setGeometryName(this.geometryName_),this.sketchFeature_.setGeometry(s),this.updateSketchFeatures_(),this.dispatchEvent(new Y(H.DRAWSTART,this.sketchFeature_))}modifyDrawing_(e){const t=this.getMap(),i=this.sketchFeature_.getGeometry(),s=t.getView().getProjection(),n=Pe(this.geometryLayout_);let r,o;for(;e.length<n;)e.push(0);this.mode_==="Point"?o=this.sketchCoords_:this.mode_==="Polygon"?(r=this.sketchCoords_[0],o=r[r.length-1],this.atFinish_(t.getPixelFromCoordinate(e))&&(e=this.finishCoordinate_.slice())):(r=this.sketchCoords_,o=r[r.length-1]),o[0]=e[0],o[1]=e[1],this.geometryFunction_(this.sketchCoords_,i,s),this.sketchPoint_&&this.sketchPoint_.getGeometry().setCoordinates(e),i.getType()==="Polygon"&&this.mode_!=="Polygon"?this.createOrUpdateCustomSketchLine_(i):this.sketchLineCoords_&&this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_),this.updateSketchFeatures_()}addToDrawing_(e){const t=this.sketchFeature_.getGeometry(),i=this.getMap().getView().getProjection();let s,n;const r=this.mode_;return r==="LineString"||r==="Circle"?(this.finishCoordinate_=e.slice(),n=this.sketchCoords_,n.length>=this.maxPoints_&&(this.freehand_?n.pop():s=!0),n.push(e.slice()),this.geometryFunction_(n,t,i)):r==="Polygon"&&(n=this.sketchCoords_[0],n.length>=this.maxPoints_&&(this.freehand_?n.pop():s=!0),n.push(e.slice()),s&&(this.finishCoordinate_=n[0]),this.geometryFunction_(this.sketchCoords_,t,i)),this.createOrUpdateSketchPoint_(e.slice()),this.updateSketchFeatures_(),s?this.finishDrawing():this.sketchFeature_}removeLastPoints_(e){if(!this.sketchFeature_)return;const t=this.sketchFeature_.getGeometry(),i=this.getMap().getView().getProjection(),s=this.mode_;for(let n=0;n<e;++n){let r;if(s==="LineString"||s==="Circle"){if(r=this.sketchCoords_,r.splice(-2,1),r.length>=2){this.finishCoordinate_=r[r.length-2].slice();const o=this.finishCoordinate_.slice();r[r.length-1]=o,this.createOrUpdateSketchPoint_(o)}this.geometryFunction_(r,t,i),t.getType()==="Polygon"&&this.sketchLine_&&this.createOrUpdateCustomSketchLine_(t)}else if(s==="Polygon"){r=this.sketchCoords_[0],r.splice(-2,1);const o=this.sketchLine_.getGeometry();if(r.length>=2){const a=r[r.length-2].slice();r[r.length-1]=a,this.createOrUpdateSketchPoint_(a)}o.setCoordinates(r),this.geometryFunction_(this.sketchCoords_,t,i)}if(r.length===1){this.abortDrawing();break}}this.updateSketchFeatures_()}removeLastPoint(){this.removeLastPoints_(1)}finishDrawing(){const e=this.abortDrawing_();if(!e)return null;let t=this.sketchCoords_;const i=e.getGeometry(),s=this.getMap().getView().getProjection();return this.mode_==="LineString"?(t.pop(),this.geometryFunction_(t,i,s)):this.mode_==="Polygon"&&(t[0].pop(),this.geometryFunction_(t,i,s),t=i.getCoordinates()),this.type_==="MultiPoint"?e.setGeometry(new re([t])):this.type_==="MultiLineString"?e.setGeometry(new B([t])):this.type_==="MultiPolygon"&&e.setGeometry(new j([t])),this.dispatchEvent(new Y(H.DRAWEND,e)),this.features_&&this.features_.push(e),this.source_&&this.source_.addFeature(e),e}abortDrawing_(){this.finishCoordinate_=null;const e=this.sketchFeature_;return this.sketchFeature_=null,this.sketchPoint_=null,this.sketchLine_=null,this.overlay_.getSource().clear(!0),this.deactivateTrace_(),e}abortDrawing(){const e=this.abortDrawing_();e&&this.dispatchEvent(new Y(H.DRAWABORT,e))}appendCoordinates(e){const t=this.mode_,i=!this.sketchFeature_;i&&this.startDrawing_(e[0]);let s;if(t==="LineString"||t==="Circle")s=this.sketchCoords_;else if(t==="Polygon")s=this.sketchCoords_&&this.sketchCoords_.length?this.sketchCoords_[0]:[];else return;i&&s.shift(),s.pop();for(let r=0;r<e.length;r++)this.addToDrawing_(e[r]);const n=e[e.length-1];this.sketchFeature_=this.addToDrawing_(n),this.modifyDrawing_(n)}extend(e){const i=e.getGeometry();this.sketchFeature_=e,this.sketchCoords_=i.getCoordinates();const s=this.sketchCoords_[this.sketchCoords_.length-1];this.finishCoordinate_=s.slice(),this.sketchCoords_.push(s.slice()),this.sketchPoint_=new v(new k(s)),this.updateSketchFeatures_(),this.dispatchEvent(new Y(H.DRAWSTART,this.sketchFeature_))}updateSketchFeatures_(){const e=[];this.sketchFeature_&&e.push(this.sketchFeature_),this.sketchLine_&&e.push(this.sketchLine_),this.sketchPoint_&&e.push(this.sketchPoint_);const t=this.overlay_.getSource();t.clear(!0),t.addFeatures(e)}updateState_(){const e=this.getMap(),t=this.getActive();(!e||!t)&&this.abortDrawing(),this.overlay_.setMap(t?e:null)}}function si(){const d=pe();return function(e,t){return d[e.getGeometry().getType()]}}function ni(){return function(d,e,t){const i=x([d[0],d[d.length-1]].map(function(n){return y(n)})),s=[[Fe(i),St(i),vt(i),wt(i),Fe(i)]];return e?e.setCoordinates(s):e=new N(s),e}}function ri(d){switch(d){case"Point":case"MultiPoint":return"Point";case"LineString":case"MultiLineString":return"LineString";case"Polygon":case"MultiPolygon":return"Polygon";case"Circle":return"Circle";default:throw new Error("Invalid type: "+d)}}var Xe=(d=>(d.line="LineString",d.circle="Circle",d.polygon="Polygon",d.rect="Circle",d))(Xe||{});const oi={rect:ni()};function Ei(d,e){let t=d.getInteractiveByType("draw");if(t)return t;const i=d.getOlMap(),s=d.getEmitter(),n=new se,r=new U({source:n});let o,a="line";const h=void 0;function l(c,u){o=new Ue({source:n,type:Xe[c],geometryFunction:u}),o.on("drawend",g=>{const f=g.feature.getGeometry(),_=Lt(f);n.clear(),s.emit("draw",{type:c,data:_})})}return l(a,h),t={id:X(),type:"draw",enabled:!1,use(c){a=c,i.removeInteraction(o);const u=oi[a];l(a,u),t.enabled&&i.addInteraction(o),s.emit("use")},enable(){t.enabled||(i.addLayer(r),i.addInteraction(o),t.enabled=!0)},close(){t.enabled&&(i.removeLayer(r),i.removeInteraction(o),t.enabled=!1)},destroy(){t.close(),r.dispose(),o.dispose()}},d.add(t),t}const de={TRANSLATESTART:"translatestart",TRANSLATING:"translating",TRANSLATEEND:"translateend"};class ce extends ne{constructor(e,t,i,s,n){super(e),this.features=t,this.coordinate=i,this.startCoordinate=s,this.mapBrowserEvent=n}}class ai extends ye{constructor(e){e=e||{},super(e),this.on,this.once,this.un,this.lastCoordinate_=null,this.startCoordinate_=null,this.features_=e.features!==void 0?e.features:null;let t;if(e.layers&&!this.features_)if(typeof e.layers=="function")t=e.layers;else{const i=e.layers;t=function(s){return i.includes(s)}}else t=V;this.layerFilter_=t,this.filter_=e.filter&&!this.features_?e.filter:V,this.hitTolerance_=e.hitTolerance?e.hitTolerance:0,this.condition_=e.condition?e.condition:Q,this.lastFeature_=null,this.addChangeListener(Oe.ACTIVE,this.handleActiveChanged_)}handleDownEvent(e){if(!e.originalEvent||!this.condition_(e))return!1;if(this.lastFeature_=this.featuresAtPixel_(e.pixel,e.map),!this.lastCoordinate_&&this.lastFeature_){this.startCoordinate_=e.coordinate,this.lastCoordinate_=e.coordinate,this.handleMoveEvent(e);const t=this.features_||new L([this.lastFeature_]);return this.dispatchEvent(new ce(de.TRANSLATESTART,t,e.coordinate,this.startCoordinate_,e)),!0}return!1}handleUpEvent(e){if(this.lastCoordinate_){this.lastCoordinate_=null,this.handleMoveEvent(e);const t=this.features_||new L([this.lastFeature_]);return this.dispatchEvent(new ce(de.TRANSLATEEND,t,e.coordinate,this.startCoordinate_,e)),this.startCoordinate_=null,!0}return!1}handleDragEvent(e){if(this.lastCoordinate_){const t=e.coordinate;e.map.getView().getProjection();const i=y(t),s=y(this.lastCoordinate_),n=i[0]-s[0],r=i[1]-s[1],o=this.features_||new L([this.lastFeature_]);o.forEach(function(a){const h=a.getGeometry();h.translate(n,r),a.setGeometry(h)}),this.lastCoordinate_=t,this.dispatchEvent(new ce(de.TRANSLATING,o,t,this.startCoordinate_,e))}}handleMoveEvent(e){const t=e.map.getViewport();this.featuresAtPixel_(e.pixel,e.map)?(t.classList.remove(this.lastCoordinate_?"ol-grab":"ol-grabbing"),t.classList.add(this.lastCoordinate_?"ol-grabbing":"ol-grab")):t.classList.remove("ol-grab","ol-grabbing")}featuresAtPixel_(e,t){return t.forEachFeatureAtPixel(e,(i,s)=>{if(!(!(i instanceof v)||!this.filter_(i,s))&&!(this.features_&&!this.features_.getArray().includes(i)))return i},{layerFilter:this.layerFilter_,hitTolerance:this.hitTolerance_})}getHitTolerance(){return this.hitTolerance_}setHitTolerance(e){this.hitTolerance_=e}setMap(e){const t=this.getMap();super.setMap(e),this.updateState_(t)}handleActiveChanged_(){this.updateState_(null)}updateState_(e){let t=this.getMap();const i=this.getActive();(!t||!i)&&(t=t||e,t&&t.getViewport().classList.remove("ol-grab","ol-grabbing"))}}function Si(d,e=!0){let t=d.getInteractiveByType("move");if(t)return t;const i=d.getOlMap(),s=d.getEmitter(),n=d.getContainer();let r=[];const o=new L([]),a=new ai({features:o});return a.on("translateend",h=>{const l=h.features.getArray()??[];e&&l.forEach(c=>{Ne(c,n)}),s.emit("move",r)}),t={id:X(),type:"move",enabled:!1,add(h){r.findIndex(c=>c.id===h.id)===-1&&(r.push(h),o.push(h.getOlFeature()))},remove(h){const l=r.findIndex(c=>c.id===h.id);l!==-1&&(r.splice(l,1),o.remove(h.getOlFeature()))},clean(){r=[],o.clear()},enable(){t.enabled||(i.addInteraction(a),t.enabled=!0)},close(){t.enabled&&(i.removeInteraction(a),t.enabled=!1)},destroy(){t.clean(),t.close(),a.dispose()}},d.add(t),t}const li={SELECT:"select"};class hi extends ne{constructor(e,t,i,s){super(e),this.selected=t,this.deselected=i,this.mapBrowserEvent=s}}const $={};class Ce extends kt{constructor(e){super(),this.on,this.once,this.un,e=e||{},this.boundAddFeature_=this.addFeature_.bind(this),this.boundRemoveFeature_=this.removeFeature_.bind(this),this.condition_=e.condition?e.condition:Ve,this.addCondition_=e.addCondition?e.addCondition:fe,this.removeCondition_=e.removeCondition?e.removeCondition:fe,this.toggleCondition_=e.toggleCondition?e.toggleCondition:Re,this.multi_=e.multi?e.multi:!1,this.filter_=e.filter?e.filter:V,this.hitTolerance_=e.hitTolerance?e.hitTolerance:0,this.style_=e.style!==void 0?e.style:di(),this.features_=e.features||new L;let t;if(e.layers)if(typeof e.layers=="function")t=e.layers;else{const i=e.layers;t=function(s){return i.includes(s)}}else t=V;this.layerFilter_=t,this.featureLayerAssociation_={}}addFeatureLayerAssociation_(e,t){this.featureLayerAssociation_[F(e)]=t}getFeatures(){return this.features_}getHitTolerance(){return this.hitTolerance_}getLayer(e){return this.featureLayerAssociation_[F(e)]}setHitTolerance(e){this.hitTolerance_=e}setMap(e){this.getMap()&&this.style_&&this.features_.forEach(this.restorePreviousStyle_.bind(this)),super.setMap(e),e?(this.features_.addEventListener(D.ADD,this.boundAddFeature_),this.features_.addEventListener(D.REMOVE,this.boundRemoveFeature_),this.style_&&this.features_.forEach(this.applySelectedStyle_.bind(this))):(this.features_.removeEventListener(D.ADD,this.boundAddFeature_),this.features_.removeEventListener(D.REMOVE,this.boundRemoveFeature_))}addFeature_(e){const t=e.element;if(this.style_&&this.applySelectedStyle_(t),!this.getLayer(t)){const i=this.getMap().getAllLayers().find(function(s){if(s instanceof U&&s.getSource()&&s.getSource().hasFeature(t))return s});i&&this.addFeatureLayerAssociation_(t,i)}}removeFeature_(e){this.style_&&this.restorePreviousStyle_(e.element)}getStyle(){return this.style_}applySelectedStyle_(e){const t=F(e);t in $||($[t]=e.getStyle()),e.setStyle(this.style_)}restorePreviousStyle_(e){const t=this.getMap().getInteractions().getArray();for(let s=t.length-1;s>=0;--s){const n=t[s];if(n!==this&&n instanceof Ce&&n.getStyle()&&n.getFeatures().getArray().lastIndexOf(e)!==-1){e.setStyle(n.getStyle());return}}const i=F(e);e.setStyle($[i]),delete $[i]}removeFeatureLayerAssociation_(e){delete this.featureLayerAssociation_[F(e)]}handleEvent(e){if(!this.condition_(e))return!0;const t=this.addCondition_(e),i=this.removeCondition_(e),s=this.toggleCondition_(e),n=!t&&!i&&!s,r=e.map,o=this.getFeatures(),a=[],h=[];if(n){It(this.featureLayerAssociation_),r.forEachFeatureAtPixel(e.pixel,(l,c)=>{if(!(!(l instanceof v)||!this.filter_(l,c)))return this.addFeatureLayerAssociation_(l,c),h.push(l),!this.multi_},{layerFilter:this.layerFilter_,hitTolerance:this.hitTolerance_});for(let l=o.getLength()-1;l>=0;--l){const c=o.item(l),u=h.indexOf(c);u>-1?h.splice(u,1):(o.remove(c),a.push(c))}h.length!==0&&o.extend(h)}else{r.forEachFeatureAtPixel(e.pixel,(l,c)=>{if(!(!(l instanceof v)||!this.filter_(l,c)))return(t||s)&&!o.getArray().includes(l)?(this.addFeatureLayerAssociation_(l,c),h.push(l)):(i||s)&&o.getArray().includes(l)&&(a.push(l),this.removeFeatureLayerAssociation_(l)),!this.multi_},{layerFilter:this.layerFilter_,hitTolerance:this.hitTolerance_});for(let l=a.length-1;l>=0;--l)o.remove(a[l]);o.extend(h)}return(h.length>0||a.length>0)&&this.dispatchEvent(new hi(li.SELECT,h,a,e)),!0}}function di(){const d=pe();return M(d.Polygon,d.LineString),M(d.GeometryCollection,d.LineString),function(e){return e.getGeometry()?d[e.getGeometry().getType()]:null}}const ci="rgba(0, 0, 255, 0.7)",ui=2;function vi(d){let e=d.getInteractiveByType("move");if(e)return e;const t=d.getOlMap(),i=d.getEmitter(),s=d.getContainer(),n=new Ce({condition:Dt,style(r){const o=Te(r,s);return[...At(o),Gt({stroke:{color:ci,width:ui}})]}});return n.on("select",function(r){const o=r.target.getFeatures().getArray()??[],a=[];o.forEach(h=>{const l=Te(h,s);l&&a.push(l)}),i.emit("select",a)}),e={id:X(),type:"select",enabled:!1,enable(){e.enabled||(t.addInteraction(n),e.enabled=!0)},close(){e.enabled&&(t.removeInteraction(n),e.enabled=!1)},destroy(){e.close(),n.dispose()}},d.add(e),e}const Me=0,O=1,Le=[0,0,0,0],R=[],ue={MODIFYSTART:"modifystart",MODIFYEND:"modifyend"};class ge extends ne{constructor(e,t,i){super(e),this.features=t,this.mapBrowserEvent=i}}class gi extends ye{constructor(e){super(e),this.on,this.once,this.un,this.boundHandleFeatureChange_=this.handleFeatureChange_.bind(this),this.condition_=e.condition?e.condition:bt,this.defaultDeleteCondition_=function(i){return Rt(i)&&Ve(i)},this.deleteCondition_=e.deleteCondition?e.deleteCondition:this.defaultDeleteCondition_,this.insertVertexCondition_=e.insertVertexCondition?e.insertVertexCondition:Q,this.vertexFeature_=null,this.vertexSegments_=null,this.lastPixel_=[0,0],this.ignoreNextSingleClick_=!1,this.featuresBeingModified_=null,this.rBush_=new Ot,this.pixelTolerance_=e.pixelTolerance!==void 0?e.pixelTolerance:10,this.snappedToVertex_=!1,this.changingFeature_=!1,this.dragSegments_=[],this.overlay_=new U({source:new se({useSpatialIndex:!1,wrapX:!!e.wrapX}),style:e.style?e.style:_i(),updateWhileAnimating:!0,updateWhileInteracting:!0}),this.SEGMENT_WRITERS_={Point:this.writePointGeometry_.bind(this),LineString:this.writeLineStringGeometry_.bind(this),LinearRing:this.writeLineStringGeometry_.bind(this),Polygon:this.writePolygonGeometry_.bind(this),MultiPoint:this.writeMultiPointGeometry_.bind(this),MultiLineString:this.writeMultiLineStringGeometry_.bind(this),MultiPolygon:this.writeMultiPolygonGeometry_.bind(this),Circle:this.writeCircleGeometry_.bind(this),GeometryCollection:this.writeGeometryCollectionGeometry_.bind(this)},this.source_=null,this.hitDetection_=null;let t;if(e.features?t=e.features:e.source&&(this.source_=e.source,t=new L(this.source_.getFeatures()),this.source_.addEventListener(Ee.ADDFEATURE,this.handleSourceAdd_.bind(this)),this.source_.addEventListener(Ee.REMOVEFEATURE,this.handleSourceRemove_.bind(this))),!t)throw new Error("The modify interaction requires features, a source or a layer");e.hitDetection&&(this.hitDetection_=e.hitDetection),this.features_=t,this.features_.forEach(this.addFeature_.bind(this)),this.features_.addEventListener(D.ADD,this.handleFeatureAdd_.bind(this)),this.features_.addEventListener(D.REMOVE,this.handleFeatureRemove_.bind(this)),this.lastPointerEvent_=null,this.delta_=[0,0],this.snapToPointer_=e.snapToPointer===void 0?!this.hitDetection_:e.snapToPointer}addFeature_(e){const t=e.getGeometry();if(t){const s=this.SEGMENT_WRITERS_[t.getType()];s&&s(e,t)}const i=this.getMap();i&&i.isRendered()&&this.getActive()&&this.handlePointerAtPixel_(i.getCoordinateFromPixel(this.lastPixel_)),e.addEventListener(z.CHANGE,this.boundHandleFeatureChange_)}willModifyFeatures_(e,t){if(!this.featuresBeingModified_){this.featuresBeingModified_=new L;const i=this.featuresBeingModified_.getArray();for(let s=0,n=t.length;s<n;++s){const r=t[s].feature;r&&!i.includes(r)&&this.featuresBeingModified_.push(r)}this.featuresBeingModified_.getLength()===0?this.featuresBeingModified_=null:this.dispatchEvent(new ge(ue.MODIFYSTART,this.featuresBeingModified_,e))}}removeFeature_(e){this.removeFeatureSegmentData_(e),this.vertexFeature_&&this.features_.getLength()===0&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.removeEventListener(z.CHANGE,this.boundHandleFeatureChange_)}removeFeatureSegmentData_(e){const t=this.rBush_,i=[];t.forEach(function(s){e===s.feature&&i.push(s)});for(let s=i.length-1;s>=0;--s){const n=i[s];for(let r=this.dragSegments_.length-1;r>=0;--r)this.dragSegments_[r][0]===n&&this.dragSegments_.splice(r,1);t.remove(n)}}setActive(e){this.vertexFeature_&&!e&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),super.setActive(e)}setMap(e){this.overlay_.setMap(e),super.setMap(e)}getOverlay(){return this.overlay_}handleSourceAdd_(e){e.feature&&this.features_.push(e.feature)}handleSourceRemove_(e){e.feature&&this.features_.remove(e.feature)}handleFeatureAdd_(e){this.addFeature_(e.element)}handleFeatureChange_(e){if(!this.changingFeature_){const t=e.target;this.removeFeature_(t),this.addFeature_(t)}}handleFeatureRemove_(e){this.removeFeature_(e.element)}writePointGeometry_(e,t){const i=t.getCoordinates(),s={feature:e,geometry:t,segment:[i,i]};this.rBush_.insert(t.getExtent(),s)}writeMultiPointGeometry_(e,t){const i=t.getCoordinates();for(let s=0,n=i.length;s<n;++s){const r=i[s],o={feature:e,geometry:t,depth:[s],index:s,segment:[r,r]};this.rBush_.insert(t.getExtent(),o)}}writeLineStringGeometry_(e,t){const i=t.getCoordinates();for(let s=0,n=i.length-1;s<n;++s){const r=i.slice(s,s+2),o={feature:e,geometry:t,index:s,segment:r};this.rBush_.insert(x(r),o)}}writeMultiLineStringGeometry_(e,t){const i=t.getCoordinates();for(let s=0,n=i.length;s<n;++s){const r=i[s];for(let o=0,a=r.length-1;o<a;++o){const h=r.slice(o,o+2),l={feature:e,geometry:t,depth:[s],index:o,segment:h};this.rBush_.insert(x(h),l)}}}writePolygonGeometry_(e,t){const i=t.getCoordinates();for(let s=0,n=i.length;s<n;++s){const r=i[s];for(let o=0,a=r.length-1;o<a;++o){const h=r.slice(o,o+2),l={feature:e,geometry:t,depth:[s],index:o,segment:h};this.rBush_.insert(x(h),l)}}}writeMultiPolygonGeometry_(e,t){const i=t.getCoordinates();for(let s=0,n=i.length;s<n;++s){const r=i[s];for(let o=0,a=r.length;o<a;++o){const h=r[o];for(let l=0,c=h.length-1;l<c;++l){const u=h.slice(l,l+2),g={feature:e,geometry:t,depth:[o,s],index:l,segment:u};this.rBush_.insert(x(u),g)}}}}writeCircleGeometry_(e,t){const i=t.getCenter(),s={feature:e,geometry:t,index:Me,segment:[i,i]},n={feature:e,geometry:t,index:O,segment:[i,i]},r=[s,n];s.featureSegments=r,n.featureSegments=r,this.rBush_.insert(oe(i),s);let o=t;this.rBush_.insert(o.getExtent(),n)}writeGeometryCollectionGeometry_(e,t){const i=t.getGeometriesArray();for(let s=0;s<i.length;++s){const n=i[s],r=this.SEGMENT_WRITERS_[n.getType()];r(e,n)}}createOrUpdateVertexFeature_(e,t,i,s){let n=this.vertexFeature_;return n?n.getGeometry().setCoordinates(e):(n=new v(new k(e)),this.vertexFeature_=n,this.overlay_.getSource().addFeature(n)),n.set("features",t),n.set("geometries",i),n.set("existing",s),n}handleEvent(e){if(!e.originalEvent)return!0;this.lastPointerEvent_=e;let t;return!e.map.getView().getInteracting()&&e.type==P.POINTERMOVE&&!this.handlingDownUpSequence&&this.handlePointerMove_(e),this.vertexFeature_&&this.deleteCondition_(e)&&(e.type!=P.SINGLECLICK||!this.ignoreNextSingleClick_?t=this.removePoint():t=!0),e.type==P.SINGLECLICK&&(this.ignoreNextSingleClick_=!1),super.handleEvent(e)&&!t}findInsertVerticesAndUpdateDragSegments_(e){this.handlePointerAtPixel_(e),this.dragSegments_.length=0,this.featuresBeingModified_=null;const t=this.vertexFeature_;if(!t)return;this.getMap().getView().getProjection();const i=[],s=t.getGeometry().getCoordinates(),n=x([s]),r=this.rBush_.getInExtent(n),o={};r.sort(fi);for(let a=0,h=r.length;a<h;++a){const l=r[a],c=l.segment;let u=F(l.geometry);const g=l.depth;if(g&&(u+="-"+g.join("-")),o[u]||(o[u]=new Array(2)),l.geometry.getType()==="Circle"&&l.index===O){const f=Ie(e,l);E(f,s)&&!o[u][0]&&(this.dragSegments_.push([l,0]),o[u][0]=l);continue}if(E(c[0],s)&&!o[u][0]){this.dragSegments_.push([l,0]),o[u][0]=l;continue}if(E(c[1],s)&&!o[u][1]){if(o[u][0]&&o[u][0].index===0){let f=l.geometry.getCoordinates();switch(l.geometry.getType()){case"LineString":case"MultiLineString":continue;case"MultiPolygon":f=f[g[1]];case"Polygon":if(l.index!==f[g[0]].length-2)continue;break}}this.dragSegments_.push([l,1]),o[u][1]=l;continue}F(c)in this.vertexSegments_&&!o[u][0]&&!o[u][1]&&i.push(l)}return i}handleDragEvent(e){this.ignoreNextSingleClick_=!1,this.willModifyFeatures_(e,this.dragSegments_.map(([n])=>n));const t=[e.coordinate[0]+this.delta_[0],e.coordinate[1]+this.delta_[1]],i=[],s=[];for(let n=0,r=this.dragSegments_.length;n<r;++n){const o=this.dragSegments_[n],a=o[0],h=a.feature;i.includes(h)||i.push(h);const l=a.geometry;s.includes(l)||s.push(l);const c=a.depth;let u;const g=a.segment,f=o[1];for(;t.length<l.getStride();)t.push(g[f][t.length]);switch(l.getType()){case"Point":u=t,g[0]=t,g[1]=t;break;case"MultiPoint":u=l.getCoordinates(),u[a.index]=t,g[0]=t,g[1]=t;break;case"LineString":u=l.getCoordinates(),u[a.index+f]=t,g[f]=t;break;case"MultiLineString":u=l.getCoordinates(),u[c[0]][a.index+f]=t,g[f]=t;break;case"Polygon":u=l.getCoordinates(),u[c[0]][a.index+f]=t,g[f]=t;break;case"MultiPolygon":u=l.getCoordinates(),u[c[1]][c[0]][a.index+f]=t,g[f]=t;break;case"Circle":const _=l;if(g[0]=t,g[1]=t,a.index===Me)this.changingFeature_=!0,_.setCenter(t),this.changingFeature_=!1;else{this.changingFeature_=!0,e.map.getView().getProjection();let m=Z(y(_.getCenter()),y(t));_.setRadius(m),this.changingFeature_=!1}break}u&&this.setGeometryCoordinates_(l,u)}this.createOrUpdateVertexFeature_(t,i,s,!0)}handleDownEvent(e){if(!this.condition_(e))return!1;const t=e.coordinate,i=this.findInsertVerticesAndUpdateDragSegments_(t);if(i!=null&&i.length&&this.insertVertexCondition_(e)&&(this.willModifyFeatures_(e,i),this.vertexFeature_)){const s=this.vertexFeature_.getGeometry().getCoordinates();for(let n=i.length-1;n>=0;--n)this.insertVertex_(i[n],s);this.ignoreNextSingleClick_=!0}return!!this.vertexFeature_}handleUpEvent(e){for(let t=this.dragSegments_.length-1;t>=0;--t){const i=this.dragSegments_[t][0],s=i.geometry;if(s.getType()==="Circle"){const n=s,r=n.getCenter(),o=i.featureSegments[0],a=i.featureSegments[1];o.segment[0]=r,o.segment[1]=r,a.segment[0]=r,a.segment[1]=r,this.rBush_.update(oe(r),o);let h=n;this.rBush_.update(h.getExtent(),a)}else this.rBush_.update(x(i.segment),i)}return this.featuresBeingModified_&&(this.dispatchEvent(new ge(ue.MODIFYEND,this.featuresBeingModified_,e)),this.featuresBeingModified_=null),!1}handlePointerMove_(e){this.lastPixel_=e.pixel,this.handlePointerAtPixel_(e.coordinate)}handlePointerAtPixel_(e){const t=this.getMap(),i=t.getPixelFromCoordinate(e);t.getView().getProjection();const s=function(o,a){return ke(e,o)-ke(e,a)};let n,r;if(this.hitDetection_){const o=typeof this.hitDetection_=="object"?a=>a===this.hitDetection_:void 0;t.forEachFeatureAtPixel(i,(a,h,l)=>{l&&l.getType()==="Point"&&(l=new k(ee(l.getCoordinates())));const c=l||a.getGeometry();if(c&&c.getType()==="Point"&&a instanceof v&&this.features_.getArray().includes(a)){r=c;const u=a.getGeometry().getFlatCoordinates().slice(0,2);n=[{feature:a,geometry:r,segment:[u,u]}]}return!0},{layerFilter:o})}if(!n){const o=Nt(oe(e,Le)),a=t.getView().getResolution()*this.pixelTolerance_,h=Vt(Bt(o,a,Le));n=this.rBush_.getInExtent(h)}if(n&&n.length>0){const o=n.sort(s)[0],a=o.segment;let h=Ie(e,o);const l=t.getPixelFromCoordinate(h);let c=Z(i,l);if(r||c<=this.pixelTolerance_){const u={};if(u[F(a)]=!0,this.snapToPointer_||(this.delta_[0]=h[0]-e[0],this.delta_[1]=h[1]-e[1]),o.geometry.getType()==="Circle"&&o.index===O)this.snappedToVertex_=!0,this.createOrUpdateVertexFeature_(h,[o.feature],[o.geometry],this.snappedToVertex_);else{const g=t.getPixelFromCoordinate(a[0]),f=t.getPixelFromCoordinate(a[1]),_=J(l,g),m=J(l,f);if(c=Math.sqrt(Math.min(_,m)),this.snappedToVertex_=c<=this.pixelTolerance_,!this.snappedToVertex_&&!this.insertVertexCondition_(this.lastPointerEvent_)){this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null);return}this.snappedToVertex_&&(h=_>m?a[1]:a[0]),this.createOrUpdateVertexFeature_(h,[o.feature],[o.geometry],this.snappedToVertex_);const C={};C[F(o.geometry)]=!0;for(let T=1,S=n.length;T<S;++T){const w=n[T].segment;if(E(a[0],w[0])&&E(a[1],w[1])||E(a[0],w[1])&&E(a[1],w[0])){const I=F(n[T].geometry);I in C||(C[I]=!0,u[F(w)]=!0)}else break}}this.vertexSegments_=u;return}}this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null)}insertVertex_(e,t){const i=e.segment,s=e.feature,n=e.geometry,r=e.depth,o=e.index;let a;for(;t.length<n.getStride();)t.push(0);switch(n.getType()){case"MultiLineString":a=n.getCoordinates(),a[r[0]].splice(o+1,0,t);break;case"Polygon":a=n.getCoordinates(),a[r[0]].splice(o+1,0,t);break;case"MultiPolygon":a=n.getCoordinates(),a[r[1]][r[0]].splice(o+1,0,t);break;case"LineString":a=n.getCoordinates(),a.splice(o+1,0,t);break;default:return!1}this.setGeometryCoordinates_(n,a);const h=this.rBush_;h.remove(e),this.updateSegmentIndices_(n,o,r,1);const l={segment:[i[0],t],feature:s,geometry:n,depth:r,index:o};h.insert(x(l.segment),l),this.dragSegments_.push([l,1]);const c={segment:[t,i[1]],feature:s,geometry:n,depth:r,index:o+1};return h.insert(x(c.segment),c),this.dragSegments_.push([c,0]),!0}updatePointer_(e){var t;return e&&this.findInsertVerticesAndUpdateDragSegments_(e),(t=this.vertexFeature_)==null?void 0:t.getGeometry().getCoordinates()}getPoint(){var t;const e=(t=this.vertexFeature_)==null?void 0:t.getGeometry().getCoordinates();return e?ee(e,this.getMap().getView().getProjection()):null}canRemovePoint(){if(!this.vertexFeature_||this.vertexFeature_.get("geometries").every(i=>i.getType()==="Circle"||i.getType().endsWith("Point")))return!1;const e=this.vertexFeature_.getGeometry().getCoordinates();return this.rBush_.getInExtent(x([e])).some(({segment:i})=>E(i[0],e)||E(i[1],e))}removePoint(e){if(e&&(e=y(e,this.getMap().getView().getProjection()),this.updatePointer_(e)),!this.lastPointerEvent_||this.lastPointerEvent_&&this.lastPointerEvent_.type!=P.POINTERDRAG){const t=this.lastPointerEvent_;this.willModifyFeatures_(t,this.dragSegments_.map(([s])=>s));const i=this.removeVertex_();return this.featuresBeingModified_&&this.dispatchEvent(new ge(ue.MODIFYEND,this.featuresBeingModified_,t)),this.featuresBeingModified_=null,i}return!1}removeVertex_(){const e=this.dragSegments_,t={};let i=!1,s,n,r,o,a,h,l,c,u,g,f;for(a=e.length-1;a>=0;--a)r=e[a],g=r[0],f=F(g.feature),g.depth&&(f+="-"+g.depth.join("-")),f in t||(t[f]={}),r[1]===0?(t[f].right=g,t[f].index=g.index):r[1]==1&&(t[f].left=g,t[f].index=g.index+1);for(f in t){switch(u=t[f].right,l=t[f].left,h=t[f].index,c=h-1,l!==void 0?g=l:g=u,c<0&&(c=0),o=g.geometry,n=o.getCoordinates(),s=n,i=!1,o.getType()){case"MultiLineString":n[g.depth[0]].length>2&&(n[g.depth[0]].splice(h,1),i=!0);break;case"LineString":n.length>2&&(n.splice(h,1),i=!0);break;case"MultiPolygon":s=s[g.depth[1]];case"Polygon":s=s[g.depth[0]],s.length>4&&(h==s.length-1&&(h=0),s.splice(h,1),i=!0,h===0&&(s.pop(),s.push(s[0]),c=s.length-1));break}if(i){this.setGeometryCoordinates_(o,n);const _=[];if(l!==void 0&&(this.rBush_.remove(l),_.push(l.segment[0])),u!==void 0&&(this.rBush_.remove(u),_.push(u.segment[1])),l!==void 0&&u!==void 0){const m={depth:g.depth,feature:g.feature,geometry:g.geometry,index:c,segment:_};this.rBush_.insert(x(m.segment),m)}this.updateSegmentIndices_(o,h,g.depth,-1),this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.length=0}}return i}canInsertPoint(){if(!this.vertexFeature_||this.vertexFeature_.get("geometries").every(i=>i.getType()==="Circle"||i.getType().endsWith("Point")))return!1;const e=this.vertexFeature_.getGeometry().getCoordinates();return this.rBush_.getInExtent(x([e])).some(({segment:i})=>!(E(i[0],e)||E(i[1],e)))}insertPoint(e){var s;const t=e?y(e,this.getMap().getView().getProjection()):(s=this.vertexFeature_)==null?void 0:s.getGeometry().getCoordinates();return t?this.findInsertVerticesAndUpdateDragSegments_(t).reduce((n,r)=>n||this.insertVertex_(r,t),!1):!1}setGeometryCoordinates_(e,t){this.changingFeature_=!0,e.setCoordinates(t),this.changingFeature_=!1}updateSegmentIndices_(e,t,i,s){this.rBush_.forEachInExtent(e.getExtent(),function(n){n.geometry===e&&(i===void 0||n.depth===void 0||jt(n.depth,i))&&n.index>t&&(n.index+=s)})}}function fi(d,e){return d.index-e.index}function ke(d,e,t){const i=e.geometry;if(i.getType()==="Circle"){let n=i;if(e.index===O){const r=J(n.getCenter(),y(d)),o=Math.sqrt(r)-n.getRadius();return o*o}}const s=y(d);return R[0]=y(e.segment[0]),R[1]=y(e.segment[1]),Xt(s,R)}function Ie(d,e,t){const i=e.geometry;if(i.getType()==="Circle"&&e.index===O)return ee(i.getClosestPoint(y(d)));const s=y(d);return R[0]=y(e.segment[0]),R[1]=y(e.segment[1]),ee(Ut(s,R))}function _i(){const d=pe();return function(e,t){return d.Point}}function wi(d,e=!0){let t=d.getInteractiveByType("modify");if(t)return t;const i=d.getOlMap(),s=d.getEmitter(),n=d.getContainer(),r=new L([]),o=new gi({features:r});let a=[];return o.on("modifyend",h=>{const l=h.features.getArray()??[];e&&l.forEach(c=>{Ne(c,n)}),s.emit("modify",a)}),t={id:X(),type:"modify",enabled:!1,add(h){a.findIndex(c=>c.id===h.id)===-1&&(a.push(h),r.push(h.getOlFeature()))},remove(h){const l=a.findIndex(c=>c.id===h.id);l!==-1&&(a.splice(l,1),r.remove(h.getOlFeature()))},clean(){a=[],r.clear()},enable(){t.enabled||(i.addInteraction(o),t.enabled=!0)},close(){t.enabled&&(i.removeInteraction(o),t.enabled=!1)},destroy(){t.clean(),t.close(),o.dispose()}},t}const p={ELEMENT:"element",MAP:"map",OFFSET:"offset",POSITION:"position",POSITIONING:"positioning"};class He extends Ht{constructor(e){super(),this.on,this.once,this.un,this.options=e,this.id=e.id,this.insertFirst=e.insertFirst!==void 0?e.insertFirst:!0,this.stopEvent=e.stopEvent!==void 0?e.stopEvent:!0,this.element=document.createElement("div"),this.element.className=e.className!==void 0?e.className:"ol-overlay-container "+Yt,this.element.style.position="absolute",this.element.style.pointerEvents="auto",this.autoPan=e.autoPan===!0?{}:e.autoPan||void 0,this.rendered={transform_:"",visible:!0},this.mapPostrenderListenerKey=null,this.addChangeListener(p.ELEMENT,this.handleElementChanged),this.addChangeListener(p.MAP,this.handleMapChanged),this.addChangeListener(p.OFFSET,this.handleOffsetChanged),this.addChangeListener(p.POSITION,this.handlePositionChanged),this.addChangeListener(p.POSITIONING,this.handlePositioningChanged),e.element!==void 0&&this.setElement(e.element),this.setOffset(e.offset!==void 0?e.offset:[0,0]),this.setPositioning(e.positioning||"top-left"),e.position!==void 0&&this.setPosition(e.position)}getElement(){return this.get(p.ELEMENT)}getId(){return this.id}getMap(){return this.get(p.MAP)||null}getOffset(){return this.get(p.OFFSET)}getPosition(){return this.get(p.POSITION)}getPositioning(){return this.get(p.POSITIONING)}handleElementChanged(){qt(this.element);const e=this.getElement();e&&this.element.appendChild(e)}handleMapChanged(){var t;this.mapPostrenderListenerKey&&((t=this.element)==null||t.remove(),Ge(this.mapPostrenderListenerKey),this.mapPostrenderListenerKey=null);const e=this.getMap();if(e){this.mapPostrenderListenerKey=be(e,Wt.POSTRENDER,this.render,this),this.updatePixelPosition();const i=this.stopEvent?e.getOverlayContainerStopEvent():e.getOverlayContainer();this.insertFirst?i.insertBefore(this.element,i.childNodes[0]||null):i.appendChild(this.element),this.performAutoPan()}}render(){this.updatePixelPosition()}handleOffsetChanged(){this.updatePixelPosition()}handlePositionChanged(){this.updatePixelPosition(),this.performAutoPan()}handlePositioningChanged(){this.updatePixelPosition()}setElement(e){this.set(p.ELEMENT,e)}setMap(e){this.set(p.MAP,e)}setOffset(e){this.set(p.OFFSET,e)}setPosition(e){this.set(p.POSITION,e)}performAutoPan(){this.autoPan&&this.panIntoView(this.autoPan)}panIntoView(e){const t=this.getMap();if(!t||!t.getTargetElement()||!this.get(p.POSITION))return;const i=this.getRect(t.getTargetElement(),t.getSize()),s=this.getElement(),n=this.getRect(s,[Kt(s),$t(s)]);e=e||{};const r=e.margin===void 0?20:e.margin;if(!zt(i,n)){const o=n[0]-i[0],a=i[2]-n[2],h=n[1]-i[1],l=i[3]-n[3],c=[0,0];if(o<0?c[0]=o-r:a<0&&(c[0]=Math.abs(a)+r),h<0?c[1]=h-r:l<0&&(c[1]=Math.abs(l)+r),c[0]!==0||c[1]!==0){const u=t.getView().getCenterInternal(),g=t.getPixelFromCoordinateInternal(u);if(!g)return;const f=[g[0]+c[0],g[1]+c[1]],_=e.animation||{};t.getView().animateInternal({center:t.getCoordinateFromPixelInternal(f),duration:_.duration,easing:_.easing})}}}getRect(e,t){const i=e.getBoundingClientRect(),s=i.left+window.pageXOffset,n=i.top+window.pageYOffset;return[s,n,s+t[0],n+t[1]]}setPositioning(e){this.set(p.POSITIONING,e)}setVisible(e){this.rendered.visible!==e&&(this.element.style.display=e?"":"none",this.rendered.visible=e)}updatePixelPosition(){const e=this.getMap(),t=this.getPosition();if(!e||!e.isRendered()||!t){this.setVisible(!1);return}const i=e.getPixelFromCoordinate(t),s=e.getSize();this.updateRenderedPosition(i,s)}updateRenderedPosition(e,t){const i=this.element.style,s=this.getOffset(),n=this.getPositioning();this.setVisible(!0);const r=Math.round(e[0]+s[0])+"px",o=Math.round(e[1]+s[1])+"px";let a="0%",h="0%";n=="bottom-right"||n=="center-right"||n=="top-right"?a="-100%":(n=="bottom-center"||n=="center-center"||n=="top-center")&&(a="-50%"),n=="bottom-left"||n=="bottom-center"||n=="bottom-right"?h="-100%":(n=="center-left"||n=="center-center"||n=="center-right")&&(h="-50%");const l=`translate(${a}, ${h}) translate(${r}, ${o})`;this.rendered.transform_!=l&&(this.rendered.transform_=l,i.transform=l)}getOptions(){return this.options}}function mi(d){const e=Zt(d);let t;return e>100?t=Math.round(e/1e3*100)/100+" km":t=Math.round(e*100)/100+" m",{output:t,data:e}}function yi(d){const e=ei(d);let t;return e>1e4?t=Math.round(e/1e6*100)/100+" km<sup>2</sup>":t=Math.round(e*100)/100+" m<sup>2</sup>",{output:t,data:e}}function Ye(d,e){var t;d.removeOverlay(e.olOverlay),(t=e.el)==null||t.remove()}function pi(d,e){Ye(d,e.tooltip)}let De=0;function Ci(d,e){De++;const t={message:"",el:null,olOverlay:null};t.el=document.createElement("div"),t.el.className="ol-tooltip ol-tooltip-measure";const i=new He({element:t.el,offset:[0,-15],positioning:"bottom-center",stopEvent:!1,insertFirst:!1});return t.olOverlay=i,d.addOverlay(i),{id:De,type:e,data:void 0,tooltip:t}}function Ae(d){const e={message:"",el:null,olOverlay:null};e.el=document.createElement("div"),e.el.className="ol-tooltip hidden";const t=new He({element:e.el,offset:[15,0],positioning:"center-left"});return e.olOverlay=t,d.addOverlay(t),e}const xi="Click to continue drawing the polygon",Pi="Click to continue drawing the line";var qe=(d=>(d.distance="LineString",d.area="Polygon",d))(qe||{});function Fi(){return new Jt({fill:new we({color:"rgba(255, 255, 255, 0.2)"}),stroke:new ve({color:"rgba(0, 0, 0, 0.5)",lineDash:[10,10],width:2}),image:new Qt({radius:5,stroke:new ve({color:"rgba(0, 0, 0, 0.7)"}),fill:new we({color:"rgba(255, 255, 255, 0.2)"})})})}function Mi(d,e){let t=d.getInteractiveByType("measure");if(t)return t;const i=d.getOlMap(),s=d.getEmitter(),n=new se,r=new U({source:n,style:{"fill-color":"rgba(255, 255, 255, 0.2)","stroke-color":"#ffcc33","stroke-width":2,"circle-radius":7,"circle-fill-color":"#ffcc33"}});let o="distance",a,h,l={el:null,olOverlay:null};const c=function(m){var T;if(m.dragging)return;let C="Click to start drawing";h&&(o==="distance"?C=Pi:C=xi),l.el.innerHTML=C,l.olOverlay.setPosition(m.coordinate),(T=l.el)==null||T.classList.remove("hidden")};function u(){a=new Ue({source:n,type:qe[o],style:Fi()}),a.on("drawstart",function(m){h=m.feature;let C=m.target.coordinate;g=Ci(i,o),_=h.getGeometry().on("change",function(T){const S=T.target;let w,I;o==="distance"?({output:w,data:I}=mi(S),C=S.getLastCoordinate()):({output:w,data:I}=yi(S),C=S.getInteriorPoint().getCoordinates()),g.data=I,g.tooltip.el.innerHTML=w,g.tooltip.olOverlay.setPosition(C)})}),a.on("drawend",function(){g.tooltip.el.className="ol-tooltip ol-tooltip-static",g.tooltip.olOverlay.setOffset([0,-7]),f.push(g),h=null,Se(_),s.emit("measure",g)})}u();let g=null,f=[],_;return t={id:X(),type:"measure",enabled:!1,enable(){t.enabled||(l=Ae(i),i.addLayer(r),i.addInteraction(a),i.on("pointermove",c),t.enabled=!0)},use(m){t.clean(),l=Ae(i),o=m,h=null,i.removeInteraction(a),a.dispose(),Se(_),u(),t.enabled&&i.addInteraction(a)},clean(){n.clear(),Ye(i,l);for(const m of f)pi(i,m);f=[]},close(){t.enabled&&(t.clean(),i.removeLayer(r),i.removeInteraction(a),i.un("pointermove",c),t.enabled=!1)},destroy(){t.clean(),t.close(),a.dispose()}},d.add(t),t}export{Ei as a,vi as b,Mi as c,Si as d,wi as e};
